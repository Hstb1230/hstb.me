[{"title":"JavaScript取网址请求串","date":"2019-02-03T17:23:27.000Z","path":"2019/02/JavaScript取网址请求串.html","text":"准确来说应该是取域名后面的那串文本，但是实在是不知道叫什么。 方法：使用substring截取url中在域名后面的文本。12345678function getQuery() &#123; var href = window.location.href; // url var host = window.location.host; // 域名 var query = href.substring( href.lastIndexOf(host) + host.length, // 要加长度 href.length ); return query;&#125; 效果：12当前URL：http://localhost/manage/?test#123456调用结果：/manage/?test#123456 使用场景：登录状态失效或不存在时，在跳转到登录页前获取当前功能页地址并传递给接口，登录后成功后跳转至该页面，优化用户体验。","tags":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://i.hstb.me/tips/tags/日常笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://i.hstb.me/tips/tags/JavaScript/"},{"name":"网址","slug":"网址","permalink":"https://i.hstb.me/tips/tags/网址/"}]},{"title":"升级HTTPS需要注意的坑","date":"2017-10-12T16:21:26.000Z","path":"2017/10/升级HTTPS需要注意的坑.html","text":"没错，就是我，又来水文章的我。 但是今天应该算是来放干货的。 应该来说，从最开始的有个小绿锁到防运营商的广告污染，HTTPS 已经成了未来站点的发展趋势，那么对应的，网上一定也会出现各种眼花缭乱的教程(包括我的，虽然我之前根本没写过的说)但这些教程总是缺点东西，我写这篇文章的目的就是为了补充一下一些坑。 那啥，怎么HTTP → HTTPS就不说了哈，我只是想说下升级到 HTTPS 后需要注意的地方。 众所周知，HTTPS 网页里面不能引用 HTTP 资源，不然会被浏览器标记为不安全，(也就是没有小绿锁，好好的逼格就这样被吃了)，那么，相信很多教程会建议你们把带有http://的内容替换成https://或者//，再高端一点的，会教你们用 世界上最好的 PHP 写个代理程序，然后配合 JavaScript 食用，这样做大概是因为某些资源站点不支持 HTTPS 。 而我就不一样了，作为一个经常长草的静态博客，我既不太想不能用拍簧片 PHP，又想看到小绿锁，那我总得找个折中的办法： 在&lt;head&gt;标签下加上这样一行&lt;meta&gt;标签，就可以让浏览器强制使用 HTTPS 协议获取网页引用的所有资源：1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt; 千万不要和我说你不知道怎么加(手动再见) 下面是效果对比： 添加前的网络访问情况 添加后的网络访问情况，敢跟我说这是审查元素改出来的效果，请主动把头伸过来，让我给你加个五毛特效 有几点得强调下： 我没测试过各大浏览器的兼容情况，据我临时百度了解，这是 W3C 在 2012 年发布的新标准里的一个内容，但我想，是个现代浏览器应该都支持。 不要以为这个 META 标签是万能的，万一你引用的资源站点只支持 HTTP 协议访问，那么不好意思，该丢的只能丢了，建议有条件的还是用代理方式获取对应资源吧。 来自咸鱼的话： 资源链接最好用//，因为浏览器会自动识别当前协议(HTTP/HTTPS)，不然以后出个新的协议又要改，那就又要接着改。 关于HTTPS网页里不能引用HTTP资源这点可能会有些争议，我印象里前两年的Chrome好像是这样。不要奇怪这个发布时间和更新，文章确实是那个时候开始写的，只不过今天(2018/04/02)才写完，原谅我的懒癌 希望终有一天，所有的站点都能上HTTPS吧","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb.me/tips/tags/HTTPS/"}]},{"title":"用PHP取图像颜色","date":"2017-10-05T17:26:38.000Z","path":"2017/10/用PHP取图像颜色.html","text":"对 将图片转为Html网页 以及发布在Github的 img2html 项目代码的一些补充 对于拥有丰富的扩展和类库的PHP来说，提取图像颜色并非难事，使用自带的GD扩展，借助其中的函数即可完成。 首先，我们需要借助 imagecreatefrom 开头的函数导入图像，(怎么获取数据就自己来吧，file_get_contents 之类的) 官方文档列出了以下函数： imagecreatefrombmp imagecreatefromgd2 imagecreatefromgd2part imagecreatefromgd imagecreatefromgif imagecreatefromjpeg imagecreatefrompng imagecreatefromstring imagecreatefromwbmp imagecreatefromwebp imagecreatefromxbm imagecreatefromxpm 这些函数均只有一个参数，但需要注意的是， 除了 imagecreatefromstring 函数外，其余函数的参数需要为文件的本地路径或网络地址，而 imagecreatefromstring 函数的参数只能为文件数据，并且 imagecreatefromstring 函数可以解析 JPEG，PNG，GIF，WBMP 和 GD2 图片文件。 这里用 png图片 做解析，因此先1$img = imagecreatefrompng('https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396'); 然后取图像的宽度与高度：12$Y = imagesy($i); //取高度$X = imagesx($i); //取宽度 如果我们要计算图像颜色的平均值，那么:12$rgb = 0; //用于统计颜色总值$n = $X * $Y; //用于记录像素点数量 然后先创建一个遍历行的循环：12for ($y=0; $y&lt;$Y; $y++) &#123; //循环行&#125; 再创建一个遍历列的循环，但是需要嵌套在行里，即：1234for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 &#125;&#125; 这时借助 imagecolorat 函数，取出指定像素点的颜色值(十进制)：12345for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 $rgb += imagecolorat($i,$x,$y); //取出点($x,$y)的颜色值后，叠加计算 &#125;&#125; 然后计算图像的平均颜色值：1$rgb = $rgb / $n; 得到的颜色值是 10进制 的，如果要转换成 16进制，可以借助函数 dechex。 最后，记得释放资源：1imagedestroy($i);","tags":[{"name":"PHP","slug":"PHP","permalink":"https://i.hstb.me/tips/tags/PHP/"},{"name":"图像操作","slug":"图像操作","permalink":"https://i.hstb.me/tips/tags/图像操作/"}]},{"title":"配置Notepad++的c语言运行脚本","date":"2017-10-04T17:41:36.000Z","path":"2017/10/配置Notepad++的c语言运行脚本.html","text":"上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。 因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。 后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。 然后上网查方法，看到的教程都是这样给的： 复制以下代码，取名编译C：cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT 复制以下代码，取名运行C：cmd /c &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT 仔细分析下，就会发现调试需要分两步操作，有点麻烦 所以我改了一下代码，将编译运行一步到位：1cmd /k gcc -o \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" &amp;&amp; \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" &amp; PAUSE &amp; EXIT 不过这样做有一个缺点，就是编译出错时，仍然会运行一次程序，如果之前又编译成功过，那么就有可能会误导你。","tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://i.hstb.me/tips/tags/环境配置/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://i.hstb.me/tips/tags/Notepad/"},{"name":"C语言","slug":"C语言","permalink":"https://i.hstb.me/tips/tags/C语言/"}]}]