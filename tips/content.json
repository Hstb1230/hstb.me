[{"title":"用PHP取图像颜色","date":"2017-10-05T17:26:38.000Z","path":"2017/10/php.html","text":"对 将图片转为Html网页 以及发布在Github的 img2html 项目代码的一些补充对于拥有丰富的扩展和类库的PHP来说，提取图像颜色并非难事，使用自带的GD扩展，借助其中的函数即可完成。 首先，我们需要借助 imagecreatefrom 开头的函数导入图像，(怎么获取数据就自己来吧，file_get_contents 之类的) 官方文档列出了以下函数： imagecreatefrombmp imagecreatefromgd2 imagecreatefromgd2part imagecreatefromgd imagecreatefromgif imagecreatefromjpeg imagecreatefrompng imagecreatefromstring imagecreatefromwbmp imagecreatefromwebp imagecreatefromxbm imagecreatefromxpm 这些函数均只有一个参数，但需要注意的是， 除了 imagecreatefromstring 函数外，其余函数的参数需要为文件的本地路径或网络地址，而 imagecreatefromstring 函数的参数只能为文件数据，并且 imagecreatefromstring 函数可以解析 JPEG，PNG，GIF，WBMP 和 GD2 图片文件。 这里用 png图片 做解析，因此先1$img = imagecreatefrompng('https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396'); 然后取图像的宽度与高度：12$Y = imagesy($i); //取高度$X = imagesx($i); //取宽度 如果我们要计算图像颜色的平均值，那么:12$rgb = 0; //用于统计颜色总值$n = $X * $Y; //用于记录像素点数量 然后先创建一个遍历行的循环：12for ($y=0; $y&lt;$Y; $y++) &#123; //循环行&#125; 再创建一个遍历列的循环，但是需要嵌套在行里，即：1234for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 &#125;&#125; 这时借助 imagecolorat 函数，取出指定像素点的颜色值(十进制)：12345for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 $rgb += imagecolorat($i,$x,$y); //取出点($x,$y)的颜色值后，叠加计算 &#125;&#125; 然后计算图像的平均颜色值：1$rgb = $rgb / $n; 得到的颜色值是 10进制 的，如果要转换成 16进制，可以借助函数 dechex。 最后，记得释放资源：1imagedestroy($i);","tags":[{"name":"PHP","slug":"PHP","permalink":"https://i.hstb.me/tips/tags/PHP/"},{"name":"图像操作","slug":"图像操作","permalink":"https://i.hstb.me/tips/tags/图像操作/"}]},{"title":"配置Notepad++的c语言运行脚本","date":"2017-10-04T17:41:36.000Z","path":"2017/10/配置Notepad++的c语言运行脚本.html","text":"上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。 因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。 后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。 然后上网查方法，看到的教程都是这样给的： 复制以下代码，取名编译C：cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT 复制以下代码，取名运行C：cmd /c &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT 仔细分析下，就会发现调试需要分两步操作，有点麻烦 所以我改了一下代码，将编译运行一步到位：1cmd /k gcc -o \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" &amp;&amp; \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" &amp; PAUSE &amp; EXIT 不过这样做有一个缺点，就是编译出错时，仍然会运行一次程序，如果之前又编译成功过，那么就有可能会误导你。","tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://i.hstb.me/tips/tags/环境配置/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://i.hstb.me/tips/tags/Notepad/"},{"name":"C语言","slug":"C语言","permalink":"https://i.hstb.me/tips/tags/C语言/"}]}]