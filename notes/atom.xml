<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes</title>
  <icon>https://www.gravatar.com/avatar/04679fa0516b40f06b23f4850d13da20</icon>
  
  <link href="/notes/atom.xml" rel="self"/>
  
  <link href="https://i.hstb1230.com/notes/"/>
  <updated>2020-02-03T17:27:55.685Z</updated>
  <id>https://i.hstb1230.com/notes/</id>
  
  <author>
    <name>Hstb</name>
    <email>i@hstb1230.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言计算素数</title>
    <link href="https://i.hstb1230.com/notes/2020/02/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E7%B4%A0%E6%95%B0.html"/>
    <id>https://i.hstb1230.com/notes/2020/02/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E7%AE%97%E7%B4%A0%E6%95%B0.html</id>
    <published>2020-02-03T17:27:55.000Z</published>
    <updated>2020-02-03T17:27:55.685Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C语言控制分隔符输出</title>
    <link href="https://i.hstb1230.com/notes/2020/02/C%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%88%86%E9%9A%94%E7%AC%A6%E8%BE%93%E5%87%BA.html"/>
    <id>https://i.hstb1230.com/notes/2020/02/C%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%88%86%E9%9A%94%E7%AC%A6%E8%BE%93%E5%87%BA.html</id>
    <published>2020-02-03T15:35:03.000Z</published>
    <updated>2020-02-03T16:59:55.570Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我又来丢人了.jpg<a id="more"></a></p></blockquote><p>目前只遇上(或者说记得)这_种, 有更多情况再补充吧</p><h3 id="以空格分隔数据"><a href="#以空格分隔数据" class="headerlink" title="以空格分隔数据"></a>以空格分隔数据</h3><p>这个无脑, 每次输出数据的时候多带个空格就好.<br>诸如: </p><ul><li><code>printf(&quot;%d &quot;, data[i]);</code></li><li><code>cout &lt;&lt; data[i] &lt;&lt; &#39; &#39;;</code></li></ul><h3 id="以空格分隔数据，但行末不得有多余空格"><a href="#以空格分隔数据，但行末不得有多余空格" class="headerlink" title="以空格分隔数据，但行末不得有多余空格"></a>以空格分隔数据，但行末不得有多余空格</h3><p>两种思路, 但至少先把数据和分隔符单独输出.<br>都是借助循环的当前位置</p><ol><li>先输出数据, 再控制输出分隔符<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data[i];</span><br><span class="line">    <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>先控制输出分隔符, 后直接输出数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>个人觉得后者会好一点, 毕竟少了n次加法运算</li></ol><h3 id="以空格分隔数据，并且每行只输出10个数据"><a href="#以空格分隔数据，并且每行只输出10个数据" class="headerlink" title="以空格分隔数据，并且每行只输出10个数据"></a>以空格分隔数据，并且每行只输出10个数据</h3><p>依旧可以参考上者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">10</span> &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data[i];</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">9</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过, 对于i不是从0开始的情况, 就要额外计算i的相对位置了, 即再减去起点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">5</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data[i];</span><br><span class="line">    <span class="keyword">if</span>((i - <span class="number">5</span>) % <span class="number">10</span> == <span class="number">9</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样显得更复杂了点, 而且控制输出分隔符的条件也要进行对应修改,<br>所以更宁愿牺牲一点空间, 引入标志变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    flag = i % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data[i];</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">9</span>) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果最后一行不需要输出换行, 修改最后一个条件即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag == <span class="number">9</span> &amp;&amp; i + <span class="number">1</span> &lt; n) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>不过这样还是要变复杂了, 水平不够, 暂未想到更好的方法.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我又来丢人了.jpg
    
    </summary>
    
    
      <category term="C语言" scheme="https://i.hstb1230.com/notes/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>C语言读入一行文本</title>
    <link href="https://i.hstb1230.com/notes/2020/01/C%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%85%A5%E4%B8%80%E8%A1%8C%E6%96%87%E6%9C%AC.html"/>
    <id>https://i.hstb1230.com/notes/2020/01/C%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%85%A5%E4%B8%80%E8%A1%8C%E6%96%87%E6%9C%AC.html</id>
    <published>2020-01-31T15:12:33.000Z</published>
    <updated>2020-01-31T19:14:49.807Z</updated>
    
    <content type="html"><![CDATA[<p>常见的坑问题, <a id="more"></a>方法可能不是特别完整, 但应该够用.</p><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h3><figure class="highlight c"><figcaption><span>C-gets.c</span><a href="/notes/downloads/code/C语言读入一行文本/C-gets.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">gets(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此方法不会读入换行</p><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><figure class="highlight c"><figcaption><span>C-scanf.c</span><a href="/notes/downloads/code/C语言读入一行文本/C-scanf.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[^\n\r]"</span>, &amp;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此方法不会读入换行</p><blockquote><p><code>%[]</code>表示输入集合, <code>^</code>表示排除<br>完整的换行应该为<code>\n\r</code>, 如果只排除了<code>\n</code>, 那么在某些Linux评测机上会出现错误</p></blockquote><h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h3><h4 id="缺陷版本"><a href="#缺陷版本" class="headerlink" title="缺陷版本"></a>缺陷版本</h4><figure class="highlight c"><figcaption><span>C-getchar.c</span><a href="/notes/downloads/code/C语言读入一行文本/C-getchar.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((s[i++] = getchar()) != <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此方法会读入换行, 而且比较难避免不同评测环境下的换行不同问题.</p><h4 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h4><figure class="highlight c"><figcaption><span>C-getchar-better.c</span><a href="/notes/downloads/code/C语言读入一行文本/C-getchar-better.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">s[i] = getchar();</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'\n'</span> || s[i] == <span class="string">'\r'</span>) <span class="keyword">break</span>;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><figure class="highlight c"><figcaption><span>CPP-getline.cpp</span><a href="/notes/downloads/code/C语言读入一行文本/CPP-getline.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此方法不会读入换行,<br>相比C语言的所有方法都好的地方就是不受到长度限制, 避免内存溢出攻击.<br>但<code>getline</code>函数实际上有三个参数:</p><ol><li><code>input</code>    -    获取数据来源的流</li><li><code>str</code>    -    放置数据的目标 string</li><li><code>delim</code>    -    分隔字符</li></ol><p>因为分割字符<code>delim</code>的默认值为换行符, 因此可以起到只读一行的效果.</p><h3 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline"></a>cin.getline</h3><figure class="highlight c"><figcaption><span>CPP-cin-getline.cpp</span><a href="/notes/downloads/code/C语言读入一行文本/CPP-cin-getline.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(s, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>.getline(s, <span class="number">1024</span>, <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此方法不会读入换行<br>需要注意的是:</p><ul><li>该方法(第一个参数)针对的是<code>char*</code>类型变量</li><li>第二个参数是读入的字符串大小<code>count</code></li><li>第三个参数(分隔符<code>delim</code>)忽略时, 为<code>\n</code></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>[1] <a href="https://zh.cppreference.com/w/c/io/fscanf" target="_blank" rel="noopener">https://zh.cppreference.com/w/c/io/fscanf</a><br>[2] <a href="https://zh.cppreference.com/w/cpp/io/basic_istream/getline" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/io/basic_istream/getline</a><br>[3] <a href="https://www.cnblogs.com/morui/p/11046579.html" target="_blank" rel="noopener">https://www.cnblogs.com/morui/p/11046579.html</a></p>]]></content>
    
    <summary type="html">
    
      常见的坑问题
    
    </summary>
    
    
      <category term="C语言" scheme="https://i.hstb1230.com/notes/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>H3C交换机绑定IPv4</title>
    <link href="https://i.hstb1230.com/notes/2019/09/H3C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%BB%91%E5%AE%9AIP.html"/>
    <id>https://i.hstb1230.com/notes/2019/09/H3C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%BB%91%E5%AE%9AIP.html</id>
    <published>2019-09-21T14:54:54.000Z</published>
    <updated>2020-01-31T19:18:56.987Z</updated>
    
    <content type="html"><![CDATA[<p>这边提到的是IPv4静态绑定，慢慢整理ing. <a id="more"></a></p><h2 id="user-bind"><a href="#user-bind" class="headerlink" title="user-bind"></a><code>user-bind</code></h2><ul><li>使用范围<br>二层以太网端口视图</li><li>指令格式<br><code>user-bind { ip-address</code><em><code>ip-address</code></em><code>| ip-address</code><em><code>ip-address</code></em><code>mac-address</code><em><code>mac-address</code></em><code>| mac-address</code><em><code>mac-address</code></em><code>} [ vlan</code><em><code>vlan-id</code></em><code>]</code></li><li>说明<br><code>ip-address</code>和<code>mac-address</code>至少要指定一项.<br>如果使用了<code>ARP Detection</code>功能，需要指定<code>vlan</code>.<br><code>mac-address</code>的格式是 <strong><code>xxxx-xxxx-xxxx</code></strong> 而不是<code>xx:xx:xx:xx:xx:xx</code>.</li><li>举例<code>[1]</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在端口GigabitEthernet1/0/1上配置一条IPv4静态绑定表项（绑定IP＋MAC）。</span></span><br><span class="line">&lt;Sysname&gt; system-view</span><br><span class="line">[Sysname] interface gigabitethernet 1/0/1</span><br><span class="line">[Sysname-GigabitEthernet1/0/1] user-bind ip-address 192.168.0.1 mac-address 0001-0001-0001</span><br></pre></td></tr></table></figure></li><li>注意事项<br>第7版中已经删除该指令。<br>某些型号的第5版也不支持该指令.</li></ul><h2 id="ip-source-binding"><a href="#ip-source-binding" class="headerlink" title="ip source binding"></a><code>ip source binding</code></h2><p>该指令有两种格式，视使用范围而定。</p><ol><li><p>系统视图(针对全局所有端口都生效)<br><code>ip source binding ip-address</code><em><code>ip-address</code></em> <code>mac-address</code><em><code>mac-address</code></em></p></li><li><p>二层以太网端口视图<br><code>ip source binding { ip-address</code><em><code>ip-address</code></em><code>| ip-address</code><em><code>ip-address</code></em><code>mac-address</code><em><code>mac-address</code></em><code>| mac-address</code><em><code>mac-address</code></em><code>} [ vlan</code><em><code>vlan-id</code></em><code>]</code></p></li></ol><ul><li><p>说明<br>端口优先使用端口上的静态绑定表项对收到的报文进行匹配，若匹配失败，再与全局静态绑定表项进行匹配。<code>[1]</code></p></li><li><p>注意事项<code>[1]</code><br>[1] 一个表项不能在同一个端口上重复绑定，但可以在不同端口上绑定。<br>[2] 当IPv4静态绑定表项与IP Source Guard功能配合时，静态绑定表项中的VLAN参数不作为过滤报文的特征项，VLAN参数指定与否，不影响IP Source Guard功能对报文的过滤结果。<br>[3] 在IPv4静态绑定表项与ARP Detection功能配合时，静态绑定表项中必须指定VLAN参数，且该VLAN为使能ARP Detection功能的VLAN，否则ARP报文将无法通过IPv4静态绑定表项的检查。<br>[4] 配置静态表项时，如果系统中已经存在相同内容的动态表项，则新添加的静态表项将会覆盖已有的动态表项。</p></li></ul><h2 id="arp-filter-binding"><a href="#arp-filter-binding" class="headerlink" title="arp filter binding"></a><code>arp filter binding</code></h2><p>这个指令可以限制特定源IP和MAC通过，但本质上并不能算绑定IP，只是因为有限制，所以设备也必须使用IP和MAC，并不能用DHCP获取到该IP。</p><ul><li>使用范围<br>二层以太网端口视图 / 二层聚合接口视图</li><li>指令格式<br><code>arp filter binding</code><em><code>ip-address</code><em><code></code></em><code>mac-address</code></em></li><li>注意事项<code>[1]</code><br>每个端口最多支持配置 <strong>8</strong> 组允许通过的ARP报文的源IP地址和源MAC地址。<br>不能在同一端口下同时配置命令 <strong><code>arp filter source</code></strong> 和 <strong><code>arp filter binding</code></strong> 。</li><li>举例<code>[1]</code><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在GigabitEthernet1/0/1下开启ARP过滤保护功能，</span></span><br><span class="line"><span class="comment"># 允许源IP地址为1.1.1.1、源MAC地址为2-2-2的ARP报文通过。</span></span><br><span class="line">&lt;Sysname&gt; system-view</span><br><span class="line">[Sysname] interface gigabitethernet 1/0/1</span><br><span class="line">[Sysname-GigabitEthernet1/0/1] arp filter binding 1.1.1.1 2-2-2</span><br></pre></td></tr></table></figure></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写这篇文章的时候，本来想抛弃<code>user-bind</code>的，因为在实践过程中发现就算提前指定了个IP给设备，设备依旧会获取到一个新IP，但是又不能上网。而最近在操作<code>S5120</code>的时候，发现它明明是第五版命令，但二层端口下也没有<code>user-bind</code>，然后去找其他绑定IP的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为知识面窄，搞不清楚<code>arp filter binding</code>、<code>arp filter source</code>、<code>ip verify source</code>、<code>ip source binding</code>这几个指令，大佬也不带我，于是去华三官网查文档，才发现只有<code>ip source binding</code>是用来绑定IP的，其他是安全性命令。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别是<code>arp filter source</code>，它是用来保护网关免受ARP攻击的，和我想的绑定IP相差甚远；<code>arp filter binding</code>只能算绑定了半个IP，因为它的作用是只允许指定IP和MAC通过，还要在DHCP上面绑定了IP或者设备上设成静态IP才能算真的绑定了；<code>ip verify source</code>也可以看做绑定命令，但是更像一个缓存，只是在同个设备第二次获取IP的时候不用再请求DHCP，并没有真正绑定。这也就解释了为什么当时用<code>?</code>查指令帮助的时候，有些命令跟的参数不是具体的IP或MAC，而是<code>ip-address</code>和<code>mac-address</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是操作<code>E528</code>的时候，发现二层端口下没有<code>ip source binding</code>指令，只能用<code>user-bind</code>，去官网查了下<code>S5120</code>的<code>ip source binding</code>，发现这两个指令的参数是一样的，但坑在于，<code>ip source binding</code>的说明中有提到使用<code>arp detection trust</code>时必须指定一个VLAN，而<code>user-bind</code>的说明没提到，以前绑定IP的时候都没有指定<code>VLAN</code>，所以就出现了开头的那种情况，然而就算整了，依旧会从DHCP服务器上获取IP。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到最后还是没能搞定这个鬼问题，似乎只能在DHCP服务器上做静态绑定，而交换机本身只能做到限制罢了。（期待被打脸的那天）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章其实写好很久了, 当初花了两三天测验, 可能是有什么事情, 哪里疏忽了, 就一直没发, 最近想想还是发了出来, 如果有什么错误请见谅, 提出后我会尽量修改. </p><p>参考链接：</p><ul><li><code>[1]</code><a href="http://www.h3c.com/cn/Service/Document_Software/" target="_blank" rel="noopener">H3C Document</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这边提到的是IPv4静态绑定，慢慢整理ing.
    
    </summary>
    
    
      <category term="H3C" scheme="https://i.hstb1230.com/notes/categories/H3C/"/>
    
      <category term="Switch" scheme="https://i.hstb1230.com/notes/categories/H3C/Switch/"/>
    
      <category term="IP" scheme="https://i.hstb1230.com/notes/categories/H3C/Switch/IP/"/>
    
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
      <category term="IP" scheme="https://i.hstb1230.com/notes/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>易语言取小数位数</title>
    <link href="https://i.hstb1230.com/notes/2019/09/%E6%98%93%E8%AF%AD%E8%A8%80%E5%8F%96%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0.html"/>
    <id>https://i.hstb1230.com/notes/2019/09/%E6%98%93%E8%AF%AD%E8%A8%80%E5%8F%96%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0.html</id>
    <published>2019-09-08T10:52:45.000Z</published>
    <updated>2020-02-03T16:48:41.767Z</updated>
    
    <content type="html"><![CDATA[<p>写了两遍，第二次写是因为发现还有<code>1e-005</code>这种操作.<a id="more"></a></p><figure class="highlight plain"><figcaption><span>getDoubleLength.e</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.版本 2</span><br><span class="line"></span><br><span class="line">.子程序 取小数位数, 整数型, , 最高6位</span><br><span class="line">.参数 小数数值, 双精度小数型, 可空</span><br><span class="line">.参数 小数文本, 文本型, 可空</span><br><span class="line">.局部变量 数值, 文本型</span><br><span class="line">.局部变量 xLoc, 整数型, , , 小数点或e的文本位置</span><br><span class="line">.局部变量 nLeft, 文本型</span><br><span class="line">.局部变量 nRight, 文本型</span><br><span class="line">.局部变量 len, 双精度小数型</span><br><span class="line"></span><br><span class="line">.判断开始 (是否为空 (小数数值) ＝ 假)</span><br><span class="line">    数值 ＝ 到文本 (小数数值)</span><br><span class="line">.判断 (是否为空 (小数文本) ＝ 假)</span><br><span class="line">    数值 ＝ 小数文本</span><br><span class="line">.默认</span><br><span class="line">    返回 (0)</span><br><span class="line">.判断结束</span><br><span class="line">xLoc ＝ 寻找文本 (数值, “e”, , 假)</span><br><span class="line">.如果真 (xLoc ≠ -1)</span><br><span class="line">    nLeft ＝ 取文本左边 (数值, xLoc － 1)</span><br><span class="line">    nRight ＝ 取文本右边 (数值, 取文本长度 (数值) － xLoc)</span><br><span class="line">    len ＝ 取小数位数 (, nLeft) － 到整数 (nRight)</span><br><span class="line">    .如果真 (len ＜ 0)</span><br><span class="line">        返回 (0)</span><br><span class="line">    .如果真结束</span><br><span class="line">    返回 (len)</span><br><span class="line">.如果真结束</span><br><span class="line">xLoc ＝ 寻找文本 (数值, “.”, , 假)</span><br><span class="line">.如果真 (xLoc ＝ -1)</span><br><span class="line">    返回 (0)</span><br><span class="line">.如果真结束</span><br><span class="line">nRight ＝ 取文本右边 (数值, 取文本长度 (数值) － xLoc)</span><br><span class="line">.判断循环首 (nRight ≠ “” 且 取文本右边 (nRight, 1) ＝ “0”)</span><br><span class="line">    .如果真 (取文本长度 (nRight) ＝ 1)</span><br><span class="line">        nRight ＝ “”</span><br><span class="line">        跳出循环 ()</span><br><span class="line">    .如果真结束</span><br><span class="line">    nRight ＝ 取文本左边 (nRight, 取文本长度 (nRight) － 1)</span><br><span class="line">.判断循环尾 ()</span><br><span class="line">返回 (取文本长度 (nRight))</span><br></pre></td></tr></table></figure><p>附件：</p><ul><li><a href="/notes/2019/09/%E6%98%93%E8%AF%AD%E8%A8%80%E5%8F%96%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0/%E4%BB%A3%E7%A0%81%E5%9B%BE.png" title="代码图.png">代码图.png</a></li><li><a href="/notes/2019/09/%E6%98%93%E8%AF%AD%E8%A8%80%E5%8F%96%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0/getDoubleLength.e" title="getDoubleLength.e">getDoubleLength.e</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了两遍，第二次写是因为发现还有&lt;code&gt;1e-005&lt;/code&gt;这种操作.
    
    </summary>
    
    
      <category term="E" scheme="https://i.hstb1230.com/notes/categories/E/"/>
    
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
      <category term="E" scheme="https://i.hstb1230.com/notes/tags/E/"/>
    
  </entry>
  
  <entry>
    <title>记一次易语言的奇怪坑</title>
    <link href="https://i.hstb1230.com/notes/2019/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%98%93%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A5%87%E6%80%AA%E5%9D%91.html"/>
    <id>https://i.hstb1230.com/notes/2019/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%98%93%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A5%87%E6%80%AA%E5%9D%91.html</id>
    <published>2019-09-07T16:24:33.000Z</published>
    <updated>2020-01-31T19:15:43.098Z</updated>
    
    <content type="html"><![CDATA[<p>明明啥也没干，可程序就是出了bug。<a id="more"></a></p><blockquote><p>重要提示:<br>本文是水文，仅做记录吐槽用，并没有分析底层原因。</p></blockquote><p>昨天给别人写插件的时候，发现一个很奇怪的坑，</p><p>给一个子程序(这里称为<code>函数A</code>)传了文本型参数(这里称为<code>原变量</code>)，但没有在函数A里对原变量做任何修改，只是读取它的文本值，可在调用完函数A后，原变量莫名奇妙的变成了空文本，或者是乱码，像是被非法修改了内存一样。</p><p>因为易语言的设定是「只要你给我传一个非基本类型的数据变量，我就强制你传的是变量地址而不是变量内容」，</p><p>于是我长了个心眼，把原变量拷贝了一份(这里称为<code>新变量</code>)再使用，</p><p>但其实就是<code>新变量 ＝ 原变量</code>罢了，因为易语言下的<code>＝</code>实际上是申请一个新变量， 所以操作新变量并不会改变原变量。</p><p>可就算这么做了，奇怪的事情还是发生了，原变量依旧像前面一样被非法篡改，简直把我搞懵了。</p><p>只好进一步的分析，发现函数A里又把原变量传给了另一个函数(这里称为<code>函数B</code>)，函数B里对新变量做了编码再覆盖操作，可是用前面的方法稍加改造后仍然如此，让我差点怀疑易语言的赋值是不是只拷贝了地址。</p><p>再用简单粗暴的<code>调试输出</code>分析了有使用原变量的几处代码后，发现使用前后的原变量内容都没有变化，只有在调用完函数A之后才发生变化，哪怕是在函数A快调用结束之前也没有变化。</p><p>所以就更懵逼了，这显然是很不科学的，</p><p>而且忘记补充了，我在win10下是没有这个问题的，是换到win7和2008下才出现的。</p><p>但是我真的已经尽力了，从快接近底层的地方已经去排查一遍也没有办法，只好简单粗暴的使用了<code>新变量 ＝ 到文本(到字节集(原变量))</code>，然后就非常正常了。</p><p>但真的很迷惑啊，难道赋值操作并没有拷贝变量吗，用了几年易语言的我表示真的不能理解(吐血…)</p><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;明明啥也没干，可程序就是出了bug。
    
    </summary>
    
    
      <category term="E" scheme="https://i.hstb1230.com/notes/categories/E/"/>
    
      <category term="变量" scheme="https://i.hstb1230.com/notes/categories/E/%E5%8F%98%E9%87%8F/"/>
    
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
      <category term="E" scheme="https://i.hstb1230.com/notes/tags/E/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7添加6in4隧道</title>
    <link href="https://i.hstb1230.com/notes/2019/08/CentOS7%E6%B7%BB%E5%8A%A06in4%E9%9A%A7%E9%81%93.html"/>
    <id>https://i.hstb1230.com/notes/2019/08/CentOS7%E6%B7%BB%E5%8A%A06in4%E9%9A%A7%E9%81%93.html</id>
    <published>2019-08-21T08:37:14.000Z</published>
    <updated>2020-02-03T16:48:58.566Z</updated>
    
    <content type="html"><![CDATA[<p>阿里云ECS对原生IPv6的支持依旧艰难，只好用上了HE的6in4隧道<a id="more"></a></p><h1 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h1><p>首先要检查系统是否开启IPv6<br>编辑<code>\etc\sysctl.conf</code>，确保包含如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6 &#x3D; 0</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 &#x3D; 0</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 &#x3D; 0</span><br></pre></td></tr></table></figure><p>如有修改，请重启系统。</p><h1 id="脚本信息"><a href="#脚本信息" class="headerlink" title="脚本信息"></a>脚本信息</h1><p>保存以下命令为文件(如<code>he-tunnel.sh</code>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_IP6=<span class="string">"2001:470:abcd:ef::2"</span> </span><br><span class="line">LOCAL_IP4=<span class="string">"192.168.1.1"</span></span><br><span class="line">REMOTE_IP6=<span class="string">"2001:470:abcd:ef::1"</span> </span><br><span class="line">REMOTE_IP4=<span class="string">"1.1.1.1"</span></span><br><span class="line">sudo ip tunnel del he-sit</span><br><span class="line">sudo ip tunnel add he-sit mode sit remote <span class="variable">$REMOTE_IP4</span> <span class="built_in">local</span> <span class="variable">$LOCAL_IP4</span> ttl 255</span><br><span class="line">sudo ip link <span class="built_in">set</span> dev he-sit up</span><br><span class="line">sudo ip -6 addr add <span class="variable">$LOCAL_IP6</span>/64 dev he-sit</span><br><span class="line">sudo ip -6 route add default via <span class="variable">$REMOTE_IP6</span> dev he-sit</span><br></pre></td></tr></table></figure><h1 id="脚本说明"><a href="#脚本说明" class="headerlink" title="脚本说明"></a>脚本说明</h1><ul><li><code>LOCAL_IP6</code>：HE分配的<code>Client IPv6 Address</code>(不要带<code>/64</code>)</li><li><code>LOCAL_IP4</code>：用于访问外网的网卡IP，专有网络系列是内网IP，早期的经典网络系列是公网IP</li><li><code>REMOTE_IP6</code>：HE分配的<code>Server IPv6 Address</code>(不要带<code>/64</code>)</li><li><code>REMOTE_IP4</code>：<code>Server IPv4 Address</code>，即服务器IP</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>运行脚本前，请先确保主机能ping通HE的服务器IP，<br>如果能ping通，但运行脚本后仍访问不了IPv6网站，请更换其他地区的隧道服务器。</p><p>第一次运行脚本会输出<code>delete tunnel &quot;he-sit&quot; failed: No such device</code>，无需在意。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -6 -c 5 -i 3 -I he-sit 2001:470:abcd:ef::1</span><br></pre></td></tr></table></figure><p><code>2001:470:abcd:ef::1</code>为前面的<code>REMOTE_IP6</code>，如果能通就说明配置正确。</p><h1 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h1><p>编辑<code>/etc/rc.d/rc.local</code>，在末尾追加一行<code>/usr/local/bin/he-tunnel.sh</code>(视脚本的具体路径而定)</p><h1 id="部分排错"><a href="#部分排错" class="headerlink" title="部分排错"></a>部分排错</h1><ul><li><p>运行脚本出现<code>bash: ./he-tunnel.sh: Permission denied</code>。</p><blockquote><p>没有执行权限，在脚本目录下执行<code>chmod 755 he-tunnel.sh</code>即可。</p></blockquote></li><li><p>运行脚本出现<code>RTNETLINK answers: Permission denied</code>。</p><blockquote><p>根据第一步操作，检查系统是否开启对IPv6的支持。</p></blockquote></li><li><p>运行脚本出现<code>RTNETLINK answers: No route to host</code>。</p><blockquote><p>一般和上一个错误一起出现，开启IPv6支持后未遇到，待补充。</p></blockquote></li><li><p>无法ping通其他IPv6地址。</p><blockquote><p>检查脚本中的<code>LOCAL_IP4</code>是否设置为用于访问外网的网卡的IP。</p></blockquote></li><li><p>运行脚本出现<code>RTNETLINK answers: File exists</code>。</p><blockquote><p>检查是否添加了多个隧道，如果不想删除其他隧道，请将脚本最后一行中的<code>default</code>修改为<code>$REMOTE_IP6/64</code></p></blockquote></li><li><p>刚开始能用电脑ping通服务器地址(这里指自己的服务器)，但是过一段时间就不行了。</p><blockquote><ol><li>检查防火墙或安全组是否放通41协议(不是TCP，也不是UDP，只是个协议号，也称GRE)，同时不要忘记检查服务商的安全组策略。</li><li>如果无法操作防火墙，可以加一个定时任务，执行内容为前面的测试脚本。</li></ol></blockquote></li><li><p>系统启动后未自动创建隧道</p><blockquote><p>检查文件<code>/etc/rc.d/rc.local</code>是否有执行权限。</p></blockquote></li></ul><p>参考链接：</p><ul><li><a href="https://github.com/tuna/ipv6.tsinghua.edu.cn/blob/master/isatap.md#linux-%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">Tsinghua isatap</a></li><li><a href="https://tunnelbroker.net/tunnel_detail.php?tid=548039#tunnelInfoTabs-2" target="_blank" rel="noopener">Example Configurations</a></li><li><a href="https://blog.chenjia.me/articles/160301-134110.html?spm=5176.bbsr283891.0.0.eaKNSM" target="_blank" rel="noopener">阿里云通过He.net添加IPV6</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里云ECS对原生IPv6的支持依旧艰难，只好用上了HE的6in4隧道
    
    </summary>
    
    
      <category term="CentOS7" scheme="https://i.hstb1230.com/notes/categories/CentOS7/"/>
    
      <category term="IPTunnel" scheme="https://i.hstb1230.com/notes/categories/CentOS7/IPTunnel/"/>
    
      <category term="6in4" scheme="https://i.hstb1230.com/notes/categories/CentOS7/IPTunnel/6in4/"/>
    
    
      <category term="IPv6" scheme="https://i.hstb1230.com/notes/tags/IPv6/"/>
    
      <category term="隧道" scheme="https://i.hstb1230.com/notes/tags/%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Python3保存requests的cookies</title>
    <link href="https://i.hstb1230.com/notes/2019/08/Python3%E4%BF%9D%E5%AD%98requests%E7%9A%84cookies.html"/>
    <id>https://i.hstb1230.com/notes/2019/08/Python3%E4%BF%9D%E5%AD%98requests%E7%9A%84cookies.html</id>
    <published>2019-08-12T09:07:50.000Z</published>
    <updated>2020-02-03T16:49:17.486Z</updated>
    
    <content type="html"><![CDATA[<p>用了几天requests后, 发现它的cookie只在本次运行脚本中有效, 这样肯定不行的.<a id="more"></a></p><p>所以要提前保存Cookie, 在下次运行脚本时使用.</p><p>目前只看到一个方法, 但是应该不止, 以后会继续补充.</p><h1 id="使用pickle"><a href="#使用pickle" class="headerlink" title="使用pickle"></a>使用pickle</h1><h2 id="保存变量"><a href="#保存变量" class="headerlink" title="保存变量"></a>保存变量</h2><figure class="highlight python"><figcaption><span>pickle-save.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'https://aq.qq.com/cn2/index'</span>)</span><br><span class="line">print(s.cookies)</span><br><span class="line"><span class="comment"># 将cookies写到文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'cookie'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(s.cookies, f)</span><br></pre></td></tr></table></figure><h2 id="恢复变量"><a href="#恢复变量" class="headerlink" title="恢复变量"></a>恢复变量</h2><figure class="highlight python"><figcaption><span>pickle-load.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件中读取cookies</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'cookie'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 使用update方法或者直接赋值</span></span><br><span class="line">    s.cookies.update(pickle.load(f))</span><br><span class="line">    <span class="comment"># s.cookies = pickle.load(f)</span></span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul><li><a href="/notes/2019/08/Python3%E4%BF%9D%E5%AD%98requests%E7%9A%84cookies/pickle-save.py" title="pickle-save.py">pickle-save.py</a></li><li><a href="/notes/2019/08/Python3%E4%BF%9D%E5%AD%98requests%E7%9A%84cookies/pickle-load.py" title="pickle-load.py">pickle-load.py</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用了几天requests后, 发现它的cookie只在本次运行脚本中有效, 这样肯定不行的.
    
    </summary>
    
    
      <category term="Python3" scheme="https://i.hstb1230.com/notes/categories/Python3/"/>
    
      <category term="requests" scheme="https://i.hstb1230.com/notes/categories/Python3/requests/"/>
    
      <category term="cookie" scheme="https://i.hstb1230.com/notes/categories/Python3/requests/cookie/"/>
    
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
      <category term="Python3" scheme="https://i.hstb1230.com/notes/tags/Python3/"/>
    
      <category term="requests" scheme="https://i.hstb1230.com/notes/tags/requests/"/>
    
      <category term="cookie" scheme="https://i.hstb1230.com/notes/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>在Python3的requests中使用自签名证书</title>
    <link href="https://i.hstb1230.com/notes/2019/07/%E5%9C%A8Python3%E7%9A%84requests%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6.html"/>
    <id>https://i.hstb1230.com/notes/2019/07/%E5%9C%A8Python3%E7%9A%84requests%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6.html</id>
    <published>2019-07-24T03:27:31.000Z</published>
    <updated>2019-08-10T10:10:11.596Z</updated>
    
    <content type="html"><![CDATA[<p>在requests下使用代理访问https网站时出现了错误<a id="more"></a></p><h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><p>Python版本为<code>3.5</code>/<code>3.6</code>/<code>3.7</code>，requests库版本为<code>2.21.0</code><br>代理软件: <code>Fiddler 4</code>，监听地址为：<code>0.0.0.0:8888</code>.</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一般情况下，我们直接访问https网页是这样的：</p><figure class="highlight python"><figcaption><span>get_https_1.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个Session对象</span></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="comment"># 使用该对象的get方法请求网站</span></span><br><span class="line">s.get(<span class="string">'https://httpbin.org/user-agent'</span>)</span><br></pre></td></tr></table></figure><p>但有时候为了抓包做分析，看看提交内容是否正确，就会用到代理</p><figure class="highlight python"><figcaption><span>get_https_2.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明一个Session对象</span></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="comment"># 声明一个变量存放代理信息</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:8888/"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"http://127.0.0.1:8888/"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 使用代理的两种方法</span></span><br><span class="line"><span class="comment"># [1] 在参数中提交代理信息</span></span><br><span class="line">s.get(<span class="string">'https://httpbin.org/user-agent'</span>, proxies=proxies)</span><br><span class="line"><span class="comment"># [2] 修改Session对象的属性</span></span><br><span class="line">s.proxies = proxies</span><br><span class="line">s.get(<span class="string">'https://httpbin.org/user-agent'</span>)</span><br></pre></td></tr></table></figure><p>然后就会出错，详细信息如下（过长，请稍微对比后自行略过）：</p><p>注：</p><ul><li><code>D:\RunEnvironment\Python36\</code>是python程序目录</li><li><code>X:/get_https_2.py</code>是代码文件</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">D:\RunEnvironment\Python36\python.exe X:/get_https_2.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\contrib\pyopenssl.py"</span>, line 456, <span class="keyword">in</span> wrap_socket</span><br><span class="line">    cnx.do_handshake()</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\OpenSSL\SSL.py"</span>, line 1915, <span class="keyword">in</span> do_handshake</span><br><span class="line">    self._raise_ssl_error(self._ssl, result)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\OpenSSL\SSL.py"</span>, line 1647, <span class="keyword">in</span> _raise_ssl_error</span><br><span class="line">    _raise_current_error()</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\OpenSSL\_util.py"</span>, line 54, <span class="keyword">in</span> exception_from_error_queue</span><br><span class="line">    raise exception_type(errors)</span><br><span class="line">OpenSSL.SSL.Error: [(<span class="string">'SSL routines'</span>, <span class="string">'tls_process_server_certificate'</span>, <span class="string">'certificate verify failed'</span>)]</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\connectionpool.py"</span>, line 594, <span class="keyword">in</span> urlopen</span><br><span class="line">    self._prepare_proxy(conn)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\connectionpool.py"</span>, line 805, <span class="keyword">in</span> _prepare_proxy</span><br><span class="line">    conn.connect()</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\connection.py"</span>, line 344, <span class="keyword">in</span> connect</span><br><span class="line">    ssl_context=context)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\util\ssl_.py"</span>, line 347, <span class="keyword">in</span> ssl_wrap_socket</span><br><span class="line">    <span class="built_in">return</span> context.wrap_socket(sock, server_hostname=server_hostname)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\contrib\pyopenssl.py"</span>, line 462, <span class="keyword">in</span> wrap_socket</span><br><span class="line">    raise ssl.SSLError(<span class="string">'bad handshake: %r'</span> % e)</span><br><span class="line">ssl.SSLError: (<span class="string">"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)"</span>,)</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\requests\adapters.py"</span>, line 449, <span class="keyword">in</span> send</span><br><span class="line">    timeout=timeout</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\connectionpool.py"</span>, line 638, <span class="keyword">in</span> urlopen</span><br><span class="line">    _stacktrace=sys.exc_info()[2])</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\urllib3\util\retry.py"</span>, line 399, <span class="keyword">in</span> increment</span><br><span class="line">    raise MaxRetryError(_pool, url, error or ResponseError(cause))</span><br><span class="line">urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host=<span class="string">'httpbin.org'</span>, port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(<span class="string">"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)"</span>,),))</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"X:/get_https_2.py"</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    r = s.get(<span class="string">'https://httpbin.org/user-agent'</span>)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\requests\sessions.py"</span>, line 546, <span class="keyword">in</span> get</span><br><span class="line">    <span class="built_in">return</span> self.request(<span class="string">'GET'</span>, url, **kwargs)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\requests\sessions.py"</span>, line 533, <span class="keyword">in</span> request</span><br><span class="line">    resp = self.send(prep, **send_kwargs)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\requests\sessions.py"</span>, line 646, <span class="keyword">in</span> send</span><br><span class="line">    r = adapter.send(request, **kwargs)</span><br><span class="line">  File <span class="string">"D:\RunEnvironment\Python36\lib\site-packages\requests\adapters.py"</span>, line 514, <span class="keyword">in</span> send</span><br><span class="line">    raise SSLError(e, request=request)</span><br><span class="line">requests.exceptions.SSLError: HTTPSConnectionPool(host=<span class="string">'httpbin.org'</span>, port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(<span class="string">"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)"</span>,),))</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 1</span><br></pre></td></tr></table></figure><p>大概说是证书校验错误(<code>certificate verify failed</code>)，于是百度一番</p><h1 id="初步解决"><a href="#初步解决" class="headerlink" title="初步解决"></a>初步解决</h1><ul><li>在<code>get</code>/<code>post</code>等请求方法中加上参数<code>verify=False</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.get(url, verify=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li>或修改整个session的属性<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.verify = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="彻底解决"><a href="#彻底解决" class="headerlink" title="彻底解决"></a>彻底解决</h1><p>虽然使用前面的做法后程序不出错了，但是每次通过代理访问https网站时又会出现警告:</p><blockquote><p><code>D:\RunEnvironment\Python36\lib\site-packages\urllib3\connectionpool.py:847</code>: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: <a href="https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings" target="_blank" rel="noopener">https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings</a></p></blockquote><p>大概意思是「现在创建的是未经验证的https请求，强烈建议添加证书验证」</p><p>同时也给了个文档地址，大概是要装<code>certifi</code>库，然后再做一些操作，不过折腾了一会也没搞懂，就放弃了.</p><p>后面去Google搜索，看到Stack Overflow上有个问题类似的帖子，阅读了下发现与我的需求差不多：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.get(<span class="string">"https://www.python.org"</span>, proxies=&#123;<span class="string">"http"</span>: <span class="string">"http://127.0.0.1:8888"</span>, <span class="string">"https"</span>:<span class="string">"http:127.0.0.1:8888"</span>&#125;,verify=<span class="string">r"FiddlerRoot.pem"</span>)</span><br></pre></td></tr></table></figure>I've got to change .cer(DER format) file into .pem(PEM format). And I realized cert parameter was not that I wanted to use. The code above is a solution for me.<footer><strong>fx-kirin</strong><cite><a href="https://stackoverflow.com/questions/28195834/how-to-capture-python-sslhttps-connection-through-fiddler2" target="_blank" rel="noopener">stackoverflow</a></cite></footer></blockquote><p>后续补充: </p><blockquote><p>execute command in a console <code>openssl x509 -inform der -in FiddlerRoot.cer -out FiddlerRoot.pem</code></p></blockquote><p>大致意思是<code>verify</code>参数可以设置成证书文件的路径，但问题出在需要的是pem格式，而Fiddler导出的证书是<code>cer</code>文件.</p><p>所以要使用OpenSSL转换，命令为<code>openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem]</code></p><ul><li><code>[FiddlerRoot.cer]</code>为你从Fiddler中导出的cer文件路径(相对或绝对路径)</li><li><code>[FiddlerRoot.pem]</code>为导出的pem文件路径.</li></ul><p>因为Windows不带OpenSSL程序，为此又特地<a href="https://i.hstb1230.com/Windows10-64bit-build-OpenSSL.html" title="" target="">摸索了几天</a>，头大</p><p>执行命令后，将pem文件路径传给<code>verify</code>，或者修改整个Session对象的<code>verify</code>属性即可.</p><p>同时，也可以给<code>verify</code>赋值pem文件的所在目录，但要先用OpenSSL附带的<code>c_rehash.pl</code>处理该文件夹.</p><figure class="highlight python"><figcaption><span>get_https_3.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个Session对象</span></span><br><span class="line">s = requests.Session()</span><br><span class="line"><span class="comment"># 修改代理信息</span></span><br><span class="line">s.proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:8888/"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"http://127.0.0.1:8888/"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 设置自定义证书</span></span><br><span class="line"><span class="comment"># # 假设证书在代码目录下的cert文件夹里，文件名为FiddlerRoot.pem</span></span><br><span class="line"><span class="comment"># # 直接使用相对路径</span></span><br><span class="line">s.verify = <span class="string">r'cert\FiddlerRoot.pem'</span></span><br><span class="line"><span class="comment"># # 如果使用了c_rehash.pl对cert文件夹做了处理，可以修改为如下一行代码</span></span><br><span class="line">s.verify = <span class="string">r'cert'</span></span><br><span class="line">s.get(<span class="string">'https://httpbin.org/user-agent'</span>)</span><br></pre></td></tr></table></figure><p>不过这工具(实际上是Perl代码文件)不怎么适应Windows，识别不到openssl路径，所以对它稍作修改，有需要可以在附件下载.</p><p>用了这个方法几天，发现还有个奇怪的坑，就是转换的pem文件只能在本次打开的Fiddler中使用，第二次打开Fiddler就会证书错误，但是导入到Windows证书管理后，浏览器是可以一直使用的，所以不知道怎么回事，有需要再摸索吧.</p><p>最后补充下这个工具的使用方法吧：</p><blockquote><p>首先需要电脑中要安装perl、openssl并配置环境变量，<br>然后在cmd中执行<code>perl c_rehash.pl pem文件所在目录</code>，<br>如果pem文件所在目录下多出了一个不明代码文件，那么就说明成功了。</p></blockquote><p>二次补充（这次应该是真的最后一次了）：</p><blockquote><p>今天给FTP服务器上TLS的时候，发现openssl生成的证书有效期只有一天，后来查了下，发现在参数列表中加个<code>-days [天数]</code>即可修改有效期.<br>因此也推测转换出来的pem证书也只有一天有效期，而我往往是开一天的Fiddler后才关，所以等我第二次打开Fiddler，也就是第二天的时候，证书自然失效了。<br>所以转换命令应为<code>openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] -days [3650]</code></p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本文代码(附件):</p><ul><li><a href="/notes/2019/07/%E5%9C%A8Python3%E7%9A%84requests%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/get_https_1.py" title="get_https_1.py">get_https_1.py</a></li><li><a href="/notes/2019/07/%E5%9C%A8Python3%E7%9A%84requests%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/get_https_2.py" title="get_https_2.py">get_https_2.py</a></li><li><a href="/notes/2019/07/%E5%9C%A8Python3%E7%9A%84requests%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/get_https_3.py" title="get_https_3.py">get_https_3.py</a></li><li><a href="/notes/2019/07/%E5%9C%A8Python3%E7%9A%84requests%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/c_rehash.pl" title="c_rehash.pl">c_rehash.pl</a></li></ul><p>参考链接:</p><ol><li><a href="https://www.cnblogs.com/tianqianlan/p/9431295.html" title="" target="">REQUESTS库的文档高级用法</a></li><li><a href="https://www.th3r3p0.com/random/python-requests-and-burp-suite.html" title="" target="">Python Requests and Burp Suite</a></li><li><a href="https://stackoverflow.com/questions/46503129/how-to-capture-python-https-traffic-in-fiddler" title="" target="">How to capture python https traffic in fiddler? - Stack Overflow</a></li><li><a href="https://stackoverflow.com/questions/28195834/how-to-capture-python-sslhttps-connection-through-fiddler2" title="" target="">How to capture python SSL(HTTPS) connection through fiddler2 - Stack Overflow</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在requests下使用代理访问https网站时出现了错误
    
    </summary>
    
    
      <category term="Python3" scheme="https://i.hstb1230.com/notes/categories/Python3/"/>
    
      <category term="requests" scheme="https://i.hstb1230.com/notes/categories/Python3/requests/"/>
    
      <category term="HTTPS" scheme="https://i.hstb1230.com/notes/categories/Python3/requests/HTTPS/"/>
    
    
      <category term="Python3" scheme="https://i.hstb1230.com/notes/tags/Python3/"/>
    
      <category term="requests" scheme="https://i.hstb1230.com/notes/tags/requests/"/>
    
      <category term="HTTPS" scheme="https://i.hstb1230.com/notes/tags/HTTPS/"/>
    
      <category term="proxy" scheme="https://i.hstb1230.com/notes/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript取网址请求串</title>
    <link href="https://i.hstb1230.com/notes/2019/02/JavaScript%E5%8F%96%E7%BD%91%E5%9D%80%E8%AF%B7%E6%B1%82%E4%B8%B2.html"/>
    <id>https://i.hstb1230.com/notes/2019/02/JavaScript%E5%8F%96%E7%BD%91%E5%9D%80%E8%AF%B7%E6%B1%82%E4%B8%B2.html</id>
    <published>2019-02-03T17:23:27.000Z</published>
    <updated>2020-01-31T19:18:23.927Z</updated>
    
    <content type="html"><![CDATA[<p>准确来说应该是取域名后面的那串文本，但是实在是不知道叫什么。<a id="more"></a></p><p>方法：使用<code>substring</code>截取url中在域名后面的文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> href = <span class="built_in">window</span>.location.href; <span class="comment">// url</span></span><br><span class="line">  <span class="keyword">var</span> host = <span class="built_in">window</span>.location.host; <span class="comment">// 域名</span></span><br><span class="line">  <span class="keyword">var</span> query = href.substring(</span><br><span class="line">    href.lastIndexOf(host) + host.length, <span class="comment">// 要加长度</span></span><br><span class="line">    href.length );</span><br><span class="line">  <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前URL：http:&#x2F;&#x2F;localhost&#x2F;manage&#x2F;?test#123456</span><br><span class="line">调用结果：&#x2F;manage&#x2F;?test#123456</span><br></pre></td></tr></table></figure><p>使用场景：登录状态失效或不存在时，在跳转到登录页前获取当前功能页地址并传递给接口，登录后成功后跳转至该页面，优化用户体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准确来说应该是取域名后面的那串文本，但是实在是不知道叫什么。
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://i.hstb1230.com/notes/categories/JavaScript/"/>
    
    
      <category term="日常丢人" scheme="https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"/>
    
      <category term="JavaScript" scheme="https://i.hstb1230.com/notes/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>升级HTTPS需要注意的坑</title>
    <link href="https://i.hstb1230.com/notes/2017/10/%E5%8D%87%E7%BA%A7HTTPS%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91.html"/>
    <id>https://i.hstb1230.com/notes/2017/10/%E5%8D%87%E7%BA%A7HTTPS%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91.html</id>
    <published>2017-10-12T16:21:26.000Z</published>
    <updated>2019-08-07T02:19:33.386Z</updated>
    
    <content type="html"><![CDATA[<p>没错，就是我，又来水文章的我。<a id="more"></a></p><p><del>但是今天应该算是来放干货的。</del></p><p>应该来说，从最开始的有个小绿锁到防运营商的广告污染，HTTPS 已经成了未来站点的发展趋势，<br>那么对应的，网上一定也会出现各种眼花缭乱的教程(<del>包括我的，虽然我之前根本没写过的说</del>)<br>但这些教程总是缺点东西，我写这篇文章的目的就是为了补充一下一些坑。</p><p>那啥，怎么<code>HTTP → HTTPS</code>就不说了哈，我只是想说下升级到 HTTPS 后需要注意的地方。</p><p>众所周知，HTTPS 网页里面不能引用 HTTP 资源，不然会被浏览器标记为<code>不安全</code>，(也就是没有小绿锁，<del>好好的逼格就这样被吃了</del>)，<br>那么，相信很多教程会建议你们把带有<code>http://</code>的内容替换成<code>https://</code>或者<code>//</code>，<br>再高端一点的，会教你们用 <del>世界上最好的</del> <code>PHP</code> 写个代理程序，然后配合 <code>JavaScript</code> 食用，这样做大概是因为某些资源站点不支持 HTTPS 。</p><p>而我就不一样了，作为一个经常长草的静态博客，我既不太想不能用<del>拍簧片</del> PHP，又想看到小绿锁，那我总得找个折中的办法：</p><p>在<code>&lt;head&gt;</code>标签下加上这样一行<code>&lt;meta&gt;</code>标签，就可以让浏览器强制使用 HTTPS 协议获取网页引用的所有资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"upgrade-insecure-requests"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>千万不要和我说你不知道怎么加(手动再见)</p><p>下面是效果对比：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.1sls.cn/Pic/png/c590fd64ef9e17030aadf4f47b7041f8" alt="添加前的网络访问情况" title="">                </div>                <div class="image-caption">添加前的网络访问情况</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.1sls.cn/Pic/png/2003183483e9b65f677d457c94981675" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img.1sls.cn/Pic/png/e9b83454df49fcf865547cdc2aba23a8" alt="添加后的网络访问情况，敢跟我说这是审查元素改出来的效果，请主动把头伸过来，让我给你加个五毛特效" title="">                </div>                <div class="image-caption">添加后的网络访问情况，敢跟我说这是审查元素改出来的效果，请主动把头伸过来，让我给你加个五毛特效</div>            </figure><p>有几点得强调下：</p><ol><li>我没测试过各大浏览器的兼容情况，据我<del>临时百度</del>了解，这是 <a href="https://www.w3.org/TR/2012/CR-CSP-20121115/" target="_blank" rel="noopener">W3C 在 2012 年发布的新标准里的一个内容</a>，但我想，是个现代浏览器应该都支持。</li><li>不要以为这个 META 标签是万能的，万一你引用的资源站点只支持 HTTP 协议访问，那么不好意思，该丢的只能丢了，建议有条件的还是用代理方式获取对应资源吧。</li></ol><blockquote><p>来自咸鱼的话：<br> 资源链接最好用<code>//</code>，因为浏览器会自动识别当前协议(<code>HTTP</code>/<code>HTTPS</code>)，不然以后出个新的协议又要改，那就又要接着改。<br> 关于HTTPS网页里不能引用HTTP资源这点可能会有些争议，我印象里前两年的Chrome好像是这样。<br><del>不要奇怪这个发布时间和更新，文章确实是那个时候开始写的，只不过今天(2018/04/02)才写完，原谅我的懒癌</del></p></blockquote><p>希望终有一天，所有的站点都能上HTTPS吧</p>]]></content>
    
    <summary type="html">
    
      只是补充点东西
    
    </summary>
    
    
      <category term="HTTPS" scheme="https://i.hstb1230.com/notes/categories/HTTPS/"/>
    
    
      <category term="HTTPS" scheme="https://i.hstb1230.com/notes/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>用PHP取图像颜色</title>
    <link href="https://i.hstb1230.com/notes/2017/10/%E7%94%A8PHP%E5%8F%96%E5%9B%BE%E5%83%8F%E9%A2%9C%E8%89%B2.html"/>
    <id>https://i.hstb1230.com/notes/2017/10/%E7%94%A8PHP%E5%8F%96%E5%9B%BE%E5%83%8F%E9%A2%9C%E8%89%B2.html</id>
    <published>2017-10-05T17:26:38.000Z</published>
    <updated>2019-08-07T02:19:28.730Z</updated>
    
    <content type="html"><![CDATA[<p>对 <a href="https://i.hstb.me/PhotoToHtml.html" title="博客上的一篇文章" target="">将图片转为Html网页</a> 以及发布在Github的 <a href="https://github.com/Hstb1230/img2html" title="无人问津" target="">img2html</a> 项目代码的一些补充<a id="more"></a></p><p>对于拥有丰富的扩展和类库的PHP来说，提取图像颜色并非难事，使用自带的<code>GD</code>扩展，借助其中的函数即可完成。</p><p>首先，我们需要借助 <code>imagecreatefrom</code> 开头的函数导入图像，(怎么获取数据就自己来吧，<code>file_get_contents</code> 之类的)</p><blockquote><p>官方文档列出了以下函数：</p></blockquote><ol><li><code>imagecreatefrombmp</code></li><li><code>imagecreatefromgd2</code></li><li><code>imagecreatefromgd2part</code></li><li><code>imagecreatefromgd</code></li><li><code>imagecreatefromgif</code></li><li><code>imagecreatefromjpeg</code></li><li><code>imagecreatefrompng</code></li><li><code>imagecreatefromstring</code></li><li><code>imagecreatefromwbmp</code></li><li><code>imagecreatefromwebp</code></li><li><code>imagecreatefromxbm</code></li><li><code>imagecreatefromxpm</code></li></ol><p>这些函数均只有一个参数，但需要注意的是，</p><blockquote><p>除了 <code>imagecreatefromstring</code> 函数外，其余函数的参数需要为文件的本地路径或网络地址，<br>而 <code>imagecreatefromstring</code> 函数的参数只能为文件数据，<br>并且 <code>imagecreatefromstring</code> 函数可以解析 <code>JPEG</code>，<code>PNG</code>，<code>GIF</code>，<code>WBMP</code> 和 <code>GD2</code> 图片文件。</p></blockquote><p>这里用 <a href="https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396" title="" target="">png图片</a> 做解析，因此先</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$img = imagecreatefrompng(<span class="string">'https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396'</span>);</span><br></pre></td></tr></table></figure><p>然后取图像的宽度与高度：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Y = imagesy($i); <span class="comment">//取高度</span></span><br><span class="line">$X = imagesx($i); <span class="comment">//取宽度</span></span><br></pre></td></tr></table></figure><p>如果我们要计算图像颜色的平均值，那么:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$rgb = <span class="number">0</span>; <span class="comment">//用于统计颜色总值</span></span><br><span class="line">$n = $X * $Y; <span class="comment">//用于记录像素点数量</span></span><br></pre></td></tr></table></figure><p>然后先创建一个遍历行的循环：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ($y=<span class="number">0</span>; $y&lt;$Y; $y++) &#123; <span class="comment">//循环行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建一个遍历列的循环，但是需要嵌套在行里，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ($y=<span class="number">0</span>; $y&lt;$Y; $y++) &#123; <span class="comment">//循环行</span></span><br><span class="line">  <span class="keyword">for</span> ($x=<span class="number">0</span>; $x&lt;$X; $x++) &#123; <span class="comment">//循环列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时借助 <code>imagecolorat</code> 函数，取出指定像素点的颜色值(十进制)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ($y=<span class="number">0</span>; $y&lt;$Y; $y++) &#123; <span class="comment">//循环行</span></span><br><span class="line">  <span class="keyword">for</span> ($x=<span class="number">0</span>; $x&lt;$X; $x++) &#123; <span class="comment">//循环列</span></span><br><span class="line">    $rgb += imagecolorat($i,$x,$y); <span class="comment">//取出点($x,$y)的颜色值后，叠加计算</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后计算图像的平均颜色值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$rgb = $rgb / $n;</span><br></pre></td></tr></table></figure><p>得到的颜色值是 10进制 的，如果要转换成 16进制，可以借助函数 <code>dechex</code>。</p><p>最后，记得释放资源：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imagedestroy($i);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 &lt;a href=&quot;https://i.hstb.me/PhotoToHtml.html&quot; title=&quot;博客上的一篇文章&quot; target=&quot;&quot;&gt;将图片转为Html网页&lt;/a&gt; 以及发布在Github的 &lt;a href=&quot;https://github.com/Hstb1230/img2html&quot; title=&quot;无人问津&quot; target=&quot;&quot;&gt;img2html&lt;/a&gt; 项目代码的一些补充
    
    </summary>
    
    
      <category term="PHP" scheme="https://i.hstb1230.com/notes/categories/PHP/"/>
    
      <category term="图像操作" scheme="https://i.hstb1230.com/notes/categories/PHP/%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="PHP" scheme="https://i.hstb1230.com/notes/tags/PHP/"/>
    
      <category term="图像操作" scheme="https://i.hstb1230.com/notes/tags/%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>配置Notepad++的c语言运行脚本</title>
    <link href="https://i.hstb1230.com/notes/2017/10/%E9%85%8D%E7%BD%AENotepad-%E7%9A%84c%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC.html"/>
    <id>https://i.hstb1230.com/notes/2017/10/%E9%85%8D%E7%BD%AENotepad-%E7%9A%84c%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC.html</id>
    <published>2017-10-04T17:41:36.000Z</published>
    <updated>2019-08-07T02:19:48.068Z</updated>
    
    <content type="html"><![CDATA[<p>上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。<br>因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。</p><p>因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，<br>但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。</p><p>后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。<a id="more"></a></p><p>然后上网查方法，看到的教程都是这样给的：</p><blockquote></blockquote><ol><li>复制以下代码，取名<code>编译C</code>：<br><code>cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT</code><blockquote></blockquote></li><li>复制以下代码，取名<code>运行C</code>：<br><code>cmd /c &quot;$(CURRENT_DIRECTORY)\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT</code></li></ol><p>仔细分析下，就会发现调试需要分两步操作，有点麻烦</p><p>所以我改了一下代码，将编译运行一步到位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd /k gcc -o <span class="string">"<span class="variable">$(CURRENT_DIRECTORY)</span>/<span class="variable">$(NAME_PART)</span>.exe"</span> <span class="string">"<span class="variable">$(FULL_CURRENT_PATH)</span>"</span>  &amp;&amp;  <span class="string">"<span class="variable">$(CURRENT_DIRECTORY)</span>/<span class="variable">$(NAME_PART)</span>.exe"</span> &amp; PAUSE &amp; EXIT</span><br></pre></td></tr></table></figure><p>不过这样做有一个缺点，就是编译出错时，仍然会运行一次程序，如果之前又编译成功过，那么就有可能会误导你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。&lt;br&gt;因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。&lt;/p&gt;
&lt;p&gt;因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，&lt;br&gt;但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。&lt;/p&gt;
&lt;p&gt;后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。
    
    </summary>
    
    
      <category term="C语言" scheme="https://i.hstb1230.com/notes/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="环境配置" scheme="https://i.hstb1230.com/notes/categories/C%E8%AF%AD%E8%A8%80/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="C语言" scheme="https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="环境配置" scheme="https://i.hstb1230.com/notes/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Notepad++" scheme="https://i.hstb1230.com/notes/tags/Notepad/"/>
    
  </entry>
  
</feed>
