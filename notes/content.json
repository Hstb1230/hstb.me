[{"title":"C语言计算素数","date":"2020-02-03T17:27:55.000Z","path":"2020/02/C语言计算素数.html","text":"","tags":[]},{"title":"C语言控制分隔符输出","date":"2020-02-03T15:35:03.000Z","path":"2020/02/C语言控制分隔符输出.html","text":"我又来丢人了.jpg 目前只遇上(或者说记得)这_种, 有更多情况再补充吧 以空格分隔数据这个无脑, 每次输出数据的时候多带个空格就好.诸如: printf(&quot;%d &quot;, data[i]); cout &lt;&lt; data[i] &lt;&lt; &#39; &#39;; 以空格分隔数据，但行末不得有多余空格两种思路, 但至少先把数据和分隔符单独输出.都是借助循环的当前位置 先输出数据, 再控制输出分隔符1234for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; data[i]; if(i + 1 &lt; n) cout &lt;&lt; ' ';&#125; 先控制输出分隔符, 后直接输出数据1234for(int i = 0; i &lt; n; i++) &#123; if(i &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; data[i];&#125; 个人觉得后者会好一点, 毕竟少了n次加法运算 以空格分隔数据，并且每行只输出10个数据依旧可以参考上者 12345for(int i = 0; i &lt; n; i++) &#123; if(i % 10 &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; data[i]; if(i % 10 == 9) cout &lt;&lt; endl;&#125; 不过, 对于i不是从0开始的情况, 就要额外计算i的相对位置了, 即再减去起点 12345for(int i = 5; i &lt; n; i++) &#123; if(i &gt; 5) cout &lt;&lt; ' '; cout &lt;&lt; data[i]; if((i - 5) % 10 == 9) cout &lt;&lt; endl;&#125; 但是这样显得更复杂了点, 而且控制输出分隔符的条件也要进行对应修改,所以更宁愿牺牲一点空间, 引入标志变量 1234567int flag = 0;for(int i = 0; i &lt; n; i++) &#123; flag = i % 10; if(flag &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; data[i]; if(flag == 9) cout &lt;&lt; endl;&#125; 如果最后一行不需要输出换行, 修改最后一个条件即可 1if(flag == 9 &amp;&amp; i + 1 &lt; n) cout &lt;&lt; endl; 不过这样还是要变复杂了, 水平不够, 暂未想到更好的方法.","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"}]},{"title":"C语言读入一行文本","date":"2020-01-31T15:12:33.000Z","path":"2020/01/C语言读入一行文本.html","text":"常见的坑问题, 方法可能不是特别完整, 但应该够用. C语言getsC-gets.cview raw123456#include &lt;stdio.h&gt;int main() { char s[20]; gets(s); printf(\"%s\", s);} 此方法不会读入换行 scanfC-scanf.cview raw123456#include &lt;stdio.h&gt;int main() { char s[20]; scanf(\"%[^\\n\\r]\", &amp;s); printf(\"%s\", s);} 此方法不会读入换行 %[]表示输入集合, ^表示排除完整的换行应该为\\n\\r, 如果只排除了\\n, 那么在某些Linux评测机上会出现错误 getchar缺陷版本C-getchar.cview raw1234567#include &lt;stdio.h&gt;int main() { char s[20] = {0}; int i = 0; while((s[i++] = getchar()) != '\\n'); printf(\"%s\", s);} 此方法会读入换行, 而且比较难避免不同评测环境下的换行不同问题. 改进版本C-getchar-better.cview raw1234567891011#include &lt;stdio.h&gt;int main() { char s[20] = {0}; int i = 0; while(1) { s[i] = getchar(); if(s[i] == '\\n' || s[i] == '\\r') break; i++; } printf(\"%s\", s);} C++getlineCPP-getline.cppview raw12345678#include &lt;iostream&gt;using namespace std;int main() { string s; getline(cin, s); cout &lt;&lt; s;} 此方法不会读入换行,相比C语言的所有方法都好的地方就是不受到长度限制, 避免内存溢出攻击.但getline函数实际上有三个参数: input - 获取数据来源的流 str - 放置数据的目标 string delim - 分隔字符 因为分割字符delim的默认值为换行符, 因此可以起到只读一行的效果. cin.getlineCPP-cin-getline.cppview raw12345678910#include &lt;iostream&gt;using namespace std;int main() { char s[1024]; cin.getline(s, 1024); cout &lt;&lt; s &lt;&lt; endl; cin.getline(s, 1024, '\\n'); cout &lt;&lt; s &lt;&lt; endl;} 此方法不会读入换行需要注意的是: 该方法(第一个参数)针对的是char*类型变量 第二个参数是读入的字符串大小count 第三个参数(分隔符delim)忽略时, 为\\n 参考链接[1] https://zh.cppreference.com/w/c/io/fscanf[2] https://zh.cppreference.com/w/cpp/io/basic_istream/getline[3] https://www.cnblogs.com/morui/p/11046579.html","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"}]},{"title":"H3C交换机绑定IPv4","date":"2019-09-21T14:54:54.000Z","path":"2019/09/H3C交换机绑定IP.html","text":"这边提到的是IPv4静态绑定，慢慢整理ing. user-bind 使用范围二层以太网端口视图 指令格式user-bind { ip-addressip-address| ip-addressip-addressmac-addressmac-address| mac-addressmac-address} [ vlanvlan-id] 说明ip-address和mac-address至少要指定一项.如果使用了ARP Detection功能，需要指定vlan.mac-address的格式是 xxxx-xxxx-xxxx 而不是xx:xx:xx:xx:xx:xx. 举例[1]1234# 在端口GigabitEthernet1/0/1上配置一条IPv4静态绑定表项（绑定IP＋MAC）。&lt;Sysname&gt; system-view[Sysname] interface gigabitethernet 1/0/1[Sysname-GigabitEthernet1/0/1] user-bind ip-address 192.168.0.1 mac-address 0001-0001-0001 注意事项第7版中已经删除该指令。某些型号的第5版也不支持该指令. ip source binding该指令有两种格式，视使用范围而定。 系统视图(针对全局所有端口都生效)ip source binding ip-addressip-address mac-addressmac-address 二层以太网端口视图ip source binding { ip-addressip-address| ip-addressip-addressmac-addressmac-address| mac-addressmac-address} [ vlanvlan-id] 说明端口优先使用端口上的静态绑定表项对收到的报文进行匹配，若匹配失败，再与全局静态绑定表项进行匹配。[1] 注意事项[1][1] 一个表项不能在同一个端口上重复绑定，但可以在不同端口上绑定。[2] 当IPv4静态绑定表项与IP Source Guard功能配合时，静态绑定表项中的VLAN参数不作为过滤报文的特征项，VLAN参数指定与否，不影响IP Source Guard功能对报文的过滤结果。[3] 在IPv4静态绑定表项与ARP Detection功能配合时，静态绑定表项中必须指定VLAN参数，且该VLAN为使能ARP Detection功能的VLAN，否则ARP报文将无法通过IPv4静态绑定表项的检查。[4] 配置静态表项时，如果系统中已经存在相同内容的动态表项，则新添加的静态表项将会覆盖已有的动态表项。 arp filter binding这个指令可以限制特定源IP和MAC通过，但本质上并不能算绑定IP，只是因为有限制，所以设备也必须使用IP和MAC，并不能用DHCP获取到该IP。 使用范围二层以太网端口视图 / 二层聚合接口视图 指令格式arp filter bindingip-addressmac-address 注意事项[1]每个端口最多支持配置 8 组允许通过的ARP报文的源IP地址和源MAC地址。不能在同一端口下同时配置命令 arp filter source 和 arp filter binding 。 举例[1]12345# 在GigabitEthernet1/0/1下开启ARP过滤保护功能，# 允许源IP地址为1.1.1.1、源MAC地址为2-2-2的ARP报文通过。&lt;Sysname&gt; system-view[Sysname] interface gigabitethernet 1/0/1[Sysname-GigabitEthernet1/0/1] arp filter binding 1.1.1.1 2-2-2 写在最后&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写这篇文章的时候，本来想抛弃user-bind的，因为在实践过程中发现就算提前指定了个IP给设备，设备依旧会获取到一个新IP，但是又不能上网。而最近在操作S5120的时候，发现它明明是第五版命令，但二层端口下也没有user-bind，然后去找其他绑定IP的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为知识面窄，搞不清楚arp filter binding、arp filter source、ip verify source、ip source binding这几个指令，大佬也不带我，于是去华三官网查文档，才发现只有ip source binding是用来绑定IP的，其他是安全性命令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别是arp filter source，它是用来保护网关免受ARP攻击的，和我想的绑定IP相差甚远；arp filter binding只能算绑定了半个IP，因为它的作用是只允许指定IP和MAC通过，还要在DHCP上面绑定了IP或者设备上设成静态IP才能算真的绑定了；ip verify source也可以看做绑定命令，但是更像一个缓存，只是在同个设备第二次获取IP的时候不用再请求DHCP，并没有真正绑定。这也就解释了为什么当时用?查指令帮助的时候，有些命令跟的参数不是具体的IP或MAC，而是ip-address和mac-address。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是操作E528的时候，发现二层端口下没有ip source binding指令，只能用user-bind，去官网查了下S5120的ip source binding，发现这两个指令的参数是一样的，但坑在于，ip source binding的说明中有提到使用arp detection trust时必须指定一个VLAN，而user-bind的说明没提到，以前绑定IP的时候都没有指定VLAN，所以就出现了开头的那种情况，然而就算整了，依旧会从DHCP服务器上获取IP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到最后还是没能搞定这个鬼问题，似乎只能在DHCP服务器上做静态绑定，而交换机本身只能做到限制罢了。（期待被打脸的那天）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章其实写好很久了, 当初花了两三天测验, 可能是有什么事情, 哪里疏忽了, 就一直没发, 最近想想还是发了出来, 如果有什么错误请见谅, 提出后我会尽量修改. 参考链接： [1]H3C Document","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"IP","slug":"IP","permalink":"https://i.hstb1230.com/notes/tags/IP/"}]},{"title":"易语言取小数位数","date":"2019-09-08T10:52:45.000Z","path":"2019/09/易语言取小数位数.html","text":"写了两遍，第二次写是因为发现还有1e-005这种操作. getDoubleLength.e1234567891011121314151617181920212223242526272829303132333435363738394041.版本 2.子程序 取小数位数, 整数型, , 最高6位.参数 小数数值, 双精度小数型, 可空.参数 小数文本, 文本型, 可空.局部变量 数值, 文本型.局部变量 xLoc, 整数型, , , 小数点或e的文本位置.局部变量 nLeft, 文本型.局部变量 nRight, 文本型.局部变量 len, 双精度小数型.判断开始 (是否为空 (小数数值) ＝ 假) 数值 ＝ 到文本 (小数数值).判断 (是否为空 (小数文本) ＝ 假) 数值 ＝ 小数文本.默认 返回 (0).判断结束xLoc ＝ 寻找文本 (数值, “e”, , 假).如果真 (xLoc ≠ -1) nLeft ＝ 取文本左边 (数值, xLoc － 1) nRight ＝ 取文本右边 (数值, 取文本长度 (数值) － xLoc) len ＝ 取小数位数 (, nLeft) － 到整数 (nRight) .如果真 (len ＜ 0) 返回 (0) .如果真结束 返回 (len).如果真结束xLoc ＝ 寻找文本 (数值, “.”, , 假).如果真 (xLoc ＝ -1) 返回 (0).如果真结束nRight ＝ 取文本右边 (数值, 取文本长度 (数值) － xLoc).判断循环首 (nRight ≠ “” 且 取文本右边 (nRight, 1) ＝ “0”) .如果真 (取文本长度 (nRight) ＝ 1) nRight ＝ “” 跳出循环 () .如果真结束 nRight ＝ 取文本左边 (nRight, 取文本长度 (nRight) － 1).判断循环尾 ()返回 (取文本长度 (nRight)) 附件： 代码图.png getDoubleLength.e","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"E","slug":"E","permalink":"https://i.hstb1230.com/notes/tags/E/"}]},{"title":"记一次易语言的奇怪坑","date":"2019-09-07T16:24:33.000Z","path":"2019/09/记一次易语言的奇怪坑.html","text":"明明啥也没干，可程序就是出了bug。 重要提示:本文是水文，仅做记录吐槽用，并没有分析底层原因。 昨天给别人写插件的时候，发现一个很奇怪的坑， 给一个子程序(这里称为函数A)传了文本型参数(这里称为原变量)，但没有在函数A里对原变量做任何修改，只是读取它的文本值，可在调用完函数A后，原变量莫名奇妙的变成了空文本，或者是乱码，像是被非法修改了内存一样。 因为易语言的设定是「只要你给我传一个非基本类型的数据变量，我就强制你传的是变量地址而不是变量内容」， 于是我长了个心眼，把原变量拷贝了一份(这里称为新变量)再使用， 但其实就是新变量 ＝ 原变量罢了，因为易语言下的＝实际上是申请一个新变量， 所以操作新变量并不会改变原变量。 可就算这么做了，奇怪的事情还是发生了，原变量依旧像前面一样被非法篡改，简直把我搞懵了。 只好进一步的分析，发现函数A里又把原变量传给了另一个函数(这里称为函数B)，函数B里对新变量做了编码再覆盖操作，可是用前面的方法稍加改造后仍然如此，让我差点怀疑易语言的赋值是不是只拷贝了地址。 再用简单粗暴的调试输出分析了有使用原变量的几处代码后，发现使用前后的原变量内容都没有变化，只有在调用完函数A之后才发生变化，哪怕是在函数A快调用结束之前也没有变化。 所以就更懵逼了，这显然是很不科学的， 而且忘记补充了，我在win10下是没有这个问题的，是换到win7和2008下才出现的。 但是我真的已经尽力了，从快接近底层的地方已经去排查一遍也没有办法，只好简单粗暴的使用了新变量 ＝ 到文本(到字节集(原变量))，然后就非常正常了。 但真的很迷惑啊，难道赋值操作并没有拷贝变量吗，用了几年易语言的我表示真的不能理解(吐血…) 本文完。","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"E","slug":"E","permalink":"https://i.hstb1230.com/notes/tags/E/"}]},{"title":"CentOS7添加6in4隧道","date":"2019-08-21T08:37:14.000Z","path":"2019/08/CentOS7添加6in4隧道.html","text":"阿里云ECS对原生IPv6的支持依旧艰难，只好用上了HE的6in4隧道 检查环境首先要检查系统是否开启IPv6编辑\\etc\\sysctl.conf，确保包含如下配置： 123net.ipv6.conf.all.disable_ipv6 &#x3D; 0net.ipv6.conf.default.disable_ipv6 &#x3D; 0net.ipv6.conf.lo.disable_ipv6 &#x3D; 0 如有修改，请重启系统。 脚本信息保存以下命令为文件(如he-tunnel.sh) 123456789LOCAL_IP6=\"2001:470:abcd:ef::2\" LOCAL_IP4=\"192.168.1.1\"REMOTE_IP6=\"2001:470:abcd:ef::1\" REMOTE_IP4=\"1.1.1.1\"sudo ip tunnel del he-sitsudo ip tunnel add he-sit mode sit remote $REMOTE_IP4 local $LOCAL_IP4 ttl 255sudo ip link set dev he-sit upsudo ip -6 addr add $LOCAL_IP6/64 dev he-sitsudo ip -6 route add default via $REMOTE_IP6 dev he-sit 脚本说明 LOCAL_IP6：HE分配的Client IPv6 Address(不要带/64) LOCAL_IP4：用于访问外网的网卡IP，专有网络系列是内网IP，早期的经典网络系列是公网IP REMOTE_IP6：HE分配的Server IPv6 Address(不要带/64) REMOTE_IP4：Server IPv4 Address，即服务器IP 注意事项运行脚本前，请先确保主机能ping通HE的服务器IP，如果能ping通，但运行脚本后仍访问不了IPv6网站，请更换其他地区的隧道服务器。 第一次运行脚本会输出delete tunnel &quot;he-sit&quot; failed: No such device，无需在意。 测试1ping -6 -c 5 -i 3 -I he-sit 2001:470:abcd:ef::1 2001:470:abcd:ef::1为前面的REMOTE_IP6，如果能通就说明配置正确。 设置开机自启编辑/etc/rc.d/rc.local，在末尾追加一行/usr/local/bin/he-tunnel.sh(视脚本的具体路径而定) 部分排错 运行脚本出现bash: ./he-tunnel.sh: Permission denied。 没有执行权限，在脚本目录下执行chmod 755 he-tunnel.sh即可。 运行脚本出现RTNETLINK answers: Permission denied。 根据第一步操作，检查系统是否开启对IPv6的支持。 运行脚本出现RTNETLINK answers: No route to host。 一般和上一个错误一起出现，开启IPv6支持后未遇到，待补充。 无法ping通其他IPv6地址。 检查脚本中的LOCAL_IP4是否设置为用于访问外网的网卡的IP。 运行脚本出现RTNETLINK answers: File exists。 检查是否添加了多个隧道，如果不想删除其他隧道，请将脚本最后一行中的default修改为$REMOTE_IP6/64 刚开始能用电脑ping通服务器地址(这里指自己的服务器)，但是过一段时间就不行了。 检查防火墙或安全组是否放通41协议(不是TCP，也不是UDP，只是个协议号，也称GRE)，同时不要忘记检查服务商的安全组策略。 如果无法操作防火墙，可以加一个定时任务，执行内容为前面的测试脚本。 系统启动后未自动创建隧道 检查文件/etc/rc.d/rc.local是否有执行权限。 参考链接： Tsinghua isatap Example Configurations 阿里云通过He.net添加IPV6","tags":[{"name":"IPv6","slug":"IPv6","permalink":"https://i.hstb1230.com/notes/tags/IPv6/"},{"name":"隧道","slug":"隧道","permalink":"https://i.hstb1230.com/notes/tags/%E9%9A%A7%E9%81%93/"}]},{"title":"Python3保存requests的cookies","date":"2019-08-12T09:07:50.000Z","path":"2019/08/Python3保存requests的cookies.html","text":"用了几天requests后, 发现它的cookie只在本次运行脚本中有效, 这样肯定不行的. 所以要提前保存Cookie, 在下次运行脚本时使用. 目前只看到一个方法, 但是应该不止, 以后会继续补充. 使用pickle保存变量pickle-save.py123456789import pickleimport requestss = requests.Session()s.get('https://aq.qq.com/cn2/index')print(s.cookies)# 将cookies写到文件with open('cookie', 'wb') as f: pickle.dump(s.cookies, f) 恢复变量pickle-load.py12345# 从文件中读取cookieswith open('cookie', 'rb') as f: # 使用update方法或者直接赋值 s.cookies.update(pickle.load(f)) # s.cookies = pickle.load(f) 附录 pickle-save.py pickle-load.py","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"Python3","slug":"Python3","permalink":"https://i.hstb1230.com/notes/tags/Python3/"},{"name":"requests","slug":"requests","permalink":"https://i.hstb1230.com/notes/tags/requests/"},{"name":"cookie","slug":"cookie","permalink":"https://i.hstb1230.com/notes/tags/cookie/"}]},{"title":"在Python3的requests中使用自签名证书","date":"2019-07-24T03:27:31.000Z","path":"2019/07/在Python3的requests中使用自签名证书.html","text":"在requests下使用代理访问https网站时出现了错误 运行环境Python版本为3.5/3.6/3.7，requests库版本为2.21.0代理软件: Fiddler 4，监听地址为：0.0.0.0:8888. 问题描述一般情况下，我们直接访问https网页是这样的： get_https_1.py123456import requests# 声明一个Session对象s = requests.Session()# 使用该对象的get方法请求网站s.get('https://httpbin.org/user-agent') 但有时候为了抓包做分析，看看提交内容是否正确，就会用到代理 get_https_2.py12345678910111213# 声明一个Session对象s = requests.Session()# 声明一个变量存放代理信息proxies = &#123; \"http\": \"http://127.0.0.1:8888/\", \"https\": \"http://127.0.0.1:8888/\"&#125;# 使用代理的两种方法# [1] 在参数中提交代理信息s.get('https://httpbin.org/user-agent', proxies=proxies)# [2] 修改Session对象的属性s.proxies = proxiess.get('https://httpbin.org/user-agent') 然后就会出错，详细信息如下（过长，请稍微对比后自行略过）： 注： D:\\RunEnvironment\\Python36\\是python程序目录 X:/get_https_2.py是代码文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354D:\\RunEnvironment\\Python36\\python.exe X:/get_https_2.pyTraceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\contrib\\pyopenssl.py\", line 456, in wrap_socket cnx.do_handshake() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\SSL.py\", line 1915, in do_handshake self._raise_ssl_error(self._ssl, result) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\SSL.py\", line 1647, in _raise_ssl_error _raise_current_error() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\_util.py\", line 54, in exception_from_error_queue raise exception_type(errors)OpenSSL.SSL.Error: [('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')]During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 594, in urlopen self._prepare_proxy(conn) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 805, in _prepare_proxy conn.connect() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connection.py\", line 344, in connect ssl_context=context) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 347, in ssl_wrap_socket return context.wrap_socket(sock, server_hostname=server_hostname) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\contrib\\pyopenssl.py\", line 462, in wrap_socket raise ssl.SSLError('bad handshake: %r' % e)ssl.SSLError: (\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",)During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\adapters.py\", line 449, in send timeout=timeout File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 638, in urlopen _stacktrace=sys.exc_info()[2]) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\util\\retry.py\", line 399, in increment raise MaxRetryError(_pool, url, error or ResponseError(cause))urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='httpbin.org', port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",),))During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"X:/get_https_2.py\", line 8, in &lt;module&gt; r = s.get('https://httpbin.org/user-agent') File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 546, in get return self.request('GET', url, **kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 533, in request resp = self.send(prep, **send_kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 646, in send r = adapter.send(request, **kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\adapters.py\", line 514, in send raise SSLError(e, request=request)requests.exceptions.SSLError: HTTPSConnectionPool(host='httpbin.org', port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",),))Process finished with exit code 1 大概说是证书校验错误(certificate verify failed)，于是百度一番 初步解决 在get/post等请求方法中加上参数verify=False1s.get(url, verify=False) 或修改整个session的属性1s.verify = False 彻底解决虽然使用前面的做法后程序不出错了，但是每次通过代理访问https网站时又会出现警告: D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py:847: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings 大概意思是「现在创建的是未经验证的https请求，强烈建议添加证书验证」 同时也给了个文档地址，大概是要装certifi库，然后再做一些操作，不过折腾了一会也没搞懂，就放弃了. 后面去Google搜索，看到Stack Overflow上有个问题类似的帖子，阅读了下发现与我的需求差不多： 1requests.get(\"https://www.python.org\", proxies=&#123;\"http\": \"http://127.0.0.1:8888\", \"https\":\"http:127.0.0.1:8888\"&#125;,verify=r\"FiddlerRoot.pem\") I've got to change .cer(DER format) file into .pem(PEM format). And I realized cert parameter was not that I wanted to use. The code above is a solution for me.fx-kirinstackoverflow 后续补充: execute command in a console openssl x509 -inform der -in FiddlerRoot.cer -out FiddlerRoot.pem 大致意思是verify参数可以设置成证书文件的路径，但问题出在需要的是pem格式，而Fiddler导出的证书是cer文件. 所以要使用OpenSSL转换，命令为openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] [FiddlerRoot.cer]为你从Fiddler中导出的cer文件路径(相对或绝对路径) [FiddlerRoot.pem]为导出的pem文件路径. 因为Windows不带OpenSSL程序，为此又特地摸索了几天，头大 执行命令后，将pem文件路径传给verify，或者修改整个Session对象的verify属性即可. 同时，也可以给verify赋值pem文件的所在目录，但要先用OpenSSL附带的c_rehash.pl处理该文件夹. get_https_3.py12345678910111213141516import requests# 声明一个Session对象s = requests.Session()# 修改代理信息s.proxies = &#123; \"http\": \"http://127.0.0.1:8888/\", \"https\": \"http://127.0.0.1:8888/\"&#125;# 设置自定义证书# # 假设证书在代码目录下的cert文件夹里，文件名为FiddlerRoot.pem# # 直接使用相对路径s.verify = r'cert\\FiddlerRoot.pem'# # 如果使用了c_rehash.pl对cert文件夹做了处理，可以修改为如下一行代码s.verify = r'cert's.get('https://httpbin.org/user-agent') 不过这工具(实际上是Perl代码文件)不怎么适应Windows，识别不到openssl路径，所以对它稍作修改，有需要可以在附件下载. 用了这个方法几天，发现还有个奇怪的坑，就是转换的pem文件只能在本次打开的Fiddler中使用，第二次打开Fiddler就会证书错误，但是导入到Windows证书管理后，浏览器是可以一直使用的，所以不知道怎么回事，有需要再摸索吧. 最后补充下这个工具的使用方法吧： 首先需要电脑中要安装perl、openssl并配置环境变量，然后在cmd中执行perl c_rehash.pl pem文件所在目录，如果pem文件所在目录下多出了一个不明代码文件，那么就说明成功了。 二次补充（这次应该是真的最后一次了）： 今天给FTP服务器上TLS的时候，发现openssl生成的证书有效期只有一天，后来查了下，发现在参数列表中加个-days [天数]即可修改有效期.因此也推测转换出来的pem证书也只有一天有效期，而我往往是开一天的Fiddler后才关，所以等我第二次打开Fiddler，也就是第二天的时候，证书自然失效了。所以转换命令应为openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] -days [3650] 附录本文代码(附件): get_https_1.py get_https_2.py get_https_3.py c_rehash.pl 参考链接: REQUESTS库的文档高级用法 Python Requests and Burp Suite How to capture python https traffic in fiddler? - Stack Overflow How to capture python SSL(HTTPS) connection through fiddler2 - Stack Overflow","tags":[{"name":"Python3","slug":"Python3","permalink":"https://i.hstb1230.com/notes/tags/Python3/"},{"name":"requests","slug":"requests","permalink":"https://i.hstb1230.com/notes/tags/requests/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb1230.com/notes/tags/HTTPS/"},{"name":"proxy","slug":"proxy","permalink":"https://i.hstb1230.com/notes/tags/proxy/"}]},{"title":"JavaScript取网址请求串","date":"2019-02-03T17:23:27.000Z","path":"2019/02/JavaScript取网址请求串.html","text":"准确来说应该是取域名后面的那串文本，但是实在是不知道叫什么。 方法：使用substring截取url中在域名后面的文本。 12345678function getQuery() &#123; var href = window.location.href; // url var host = window.location.host; // 域名 var query = href.substring( href.lastIndexOf(host) + host.length, // 要加长度 href.length ); return query;&#125; 效果： 12当前URL：http:&#x2F;&#x2F;localhost&#x2F;manage&#x2F;?test#123456调用结果：&#x2F;manage&#x2F;?test#123456 使用场景：登录状态失效或不存在时，在跳转到登录页前获取当前功能页地址并传递给接口，登录后成功后跳转至该页面，优化用户体验。","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://i.hstb1230.com/notes/tags/JavaScript/"}]},{"title":"升级HTTPS需要注意的坑","date":"2017-10-12T16:21:26.000Z","path":"2017/10/升级HTTPS需要注意的坑.html","text":"没错，就是我，又来水文章的我。 但是今天应该算是来放干货的。 应该来说，从最开始的有个小绿锁到防运营商的广告污染，HTTPS 已经成了未来站点的发展趋势，那么对应的，网上一定也会出现各种眼花缭乱的教程(包括我的，虽然我之前根本没写过的说)但这些教程总是缺点东西，我写这篇文章的目的就是为了补充一下一些坑。 那啥，怎么HTTP → HTTPS就不说了哈，我只是想说下升级到 HTTPS 后需要注意的地方。 众所周知，HTTPS 网页里面不能引用 HTTP 资源，不然会被浏览器标记为不安全，(也就是没有小绿锁，好好的逼格就这样被吃了)，那么，相信很多教程会建议你们把带有http://的内容替换成https://或者//，再高端一点的，会教你们用 世界上最好的 PHP 写个代理程序，然后配合 JavaScript 食用，这样做大概是因为某些资源站点不支持 HTTPS 。 而我就不一样了，作为一个经常长草的静态博客，我既不太想不能用拍簧片 PHP，又想看到小绿锁，那我总得找个折中的办法： 在&lt;head&gt;标签下加上这样一行&lt;meta&gt;标签，就可以让浏览器强制使用 HTTPS 协议获取网页引用的所有资源： 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt; 千万不要和我说你不知道怎么加(手动再见) 下面是效果对比： 添加前的网络访问情况 添加后的网络访问情况，敢跟我说这是审查元素改出来的效果，请主动把头伸过来，让我给你加个五毛特效 有几点得强调下： 我没测试过各大浏览器的兼容情况，据我临时百度了解，这是 W3C 在 2012 年发布的新标准里的一个内容，但我想，是个现代浏览器应该都支持。 不要以为这个 META 标签是万能的，万一你引用的资源站点只支持 HTTP 协议访问，那么不好意思，该丢的只能丢了，建议有条件的还是用代理方式获取对应资源吧。 来自咸鱼的话： 资源链接最好用//，因为浏览器会自动识别当前协议(HTTP/HTTPS)，不然以后出个新的协议又要改，那就又要接着改。 关于HTTPS网页里不能引用HTTP资源这点可能会有些争议，我印象里前两年的Chrome好像是这样。不要奇怪这个发布时间和更新，文章确实是那个时候开始写的，只不过今天(2018/04/02)才写完，原谅我的懒癌 希望终有一天，所有的站点都能上HTTPS吧","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb1230.com/notes/tags/HTTPS/"}]},{"title":"用PHP取图像颜色","date":"2017-10-05T17:26:38.000Z","path":"2017/10/用PHP取图像颜色.html","text":"对 将图片转为Html网页 以及发布在Github的 img2html 项目代码的一些补充 对于拥有丰富的扩展和类库的PHP来说，提取图像颜色并非难事，使用自带的GD扩展，借助其中的函数即可完成。 首先，我们需要借助 imagecreatefrom 开头的函数导入图像，(怎么获取数据就自己来吧，file_get_contents 之类的) 官方文档列出了以下函数： imagecreatefrombmp imagecreatefromgd2 imagecreatefromgd2part imagecreatefromgd imagecreatefromgif imagecreatefromjpeg imagecreatefrompng imagecreatefromstring imagecreatefromwbmp imagecreatefromwebp imagecreatefromxbm imagecreatefromxpm 这些函数均只有一个参数，但需要注意的是， 除了 imagecreatefromstring 函数外，其余函数的参数需要为文件的本地路径或网络地址，而 imagecreatefromstring 函数的参数只能为文件数据，并且 imagecreatefromstring 函数可以解析 JPEG，PNG，GIF，WBMP 和 GD2 图片文件。 这里用 png图片 做解析，因此先 1$img = imagecreatefrompng('https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396'); 然后取图像的宽度与高度： 12$Y = imagesy($i); //取高度$X = imagesx($i); //取宽度 如果我们要计算图像颜色的平均值，那么: 12$rgb = 0; //用于统计颜色总值$n = $X * $Y; //用于记录像素点数量 然后先创建一个遍历行的循环： 12for ($y=0; $y&lt;$Y; $y++) &#123; //循环行&#125; 再创建一个遍历列的循环，但是需要嵌套在行里，即： 1234for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 &#125;&#125; 这时借助 imagecolorat 函数，取出指定像素点的颜色值(十进制)： 12345for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 $rgb += imagecolorat($i,$x,$y); //取出点($x,$y)的颜色值后，叠加计算 &#125;&#125; 然后计算图像的平均颜色值： 1$rgb = $rgb / $n; 得到的颜色值是 10进制 的，如果要转换成 16进制，可以借助函数 dechex。 最后，记得释放资源： 1imagedestroy($i);","tags":[{"name":"PHP","slug":"PHP","permalink":"https://i.hstb1230.com/notes/tags/PHP/"},{"name":"图像操作","slug":"图像操作","permalink":"https://i.hstb1230.com/notes/tags/%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"}]},{"title":"配置Notepad++的c语言运行脚本","date":"2017-10-04T17:41:36.000Z","path":"2017/10/配置Notepad-的c语言运行脚本.html","text":"上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。 因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。 后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。 然后上网查方法，看到的教程都是这样给的： 复制以下代码，取名编译C：cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT 复制以下代码，取名运行C：cmd /c &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT 仔细分析下，就会发现调试需要分两步操作，有点麻烦 所以我改了一下代码，将编译运行一步到位： 1cmd /k gcc -o \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" &amp;&amp; \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" &amp; PAUSE &amp; EXIT 不过这样做有一个缺点，就是编译出错时，仍然会运行一次程序，如果之前又编译成功过，那么就有可能会误导你。","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"环境配置","slug":"环境配置","permalink":"https://i.hstb1230.com/notes/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://i.hstb1230.com/notes/tags/Notepad/"}]}]