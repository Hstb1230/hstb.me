[{"title":"CentOS7添加6in4隧道","date":"2019-08-21T08:37:14.000Z","path":"2019/08/CentOS7添加6in4隧道.html","text":"阿里云ECS对原生IPV6的支持依旧艰难，只好用上了HE的6in4隧道 脚本信息保存以下命令为文件(如he-tunnel.sh) 123456789LOCAL_IP6=\"2001:470:abcd:ef::2\" LOCAL_IP4=\"192.168.1.1\"REMOTE_IP6=\"2001:470:abcd:ef::1\" REMOTE_IP4=\"1.1.1.1\"sudo ip tunnel del he-sitsudo ip tunnel add he-sit mode sit remote $REMOTE_IP4 local $LOCAL_IP4 ttl 255sudo ip link set dev he-sit upsudo ip -6 addr add $LOCAL_IP6/64 dev he-sitsudo ip -6 route add default via $REMOTE_IP6 dev he-sit 脚本说明 LOCAL_IP6：HE分配的Client IPv6 Address(不要带/64) LOCAL_IP4：用于访问外网的网卡IP，专有网络系列是内网IP，早期的经典网络系列是公网IP REMOTE_IP6：HE分配的Server IPv6 Address(不要带/64) REMOTE_IP4：Server IPv4 Address，即服务器IP 注意事项运行脚本前，请先确保主机能ping通HE的服务器IP，如果能ping通，但运行脚本后仍访问不了IPV6网站，请更换其他地区的隧道服务器。 第一次运行脚本会输出delete tunnel &quot;he-sit&quot; failed: No such device，无需在意。 测试1ping6 -I he-sit -c 5 2001:470:abcd:ef::1 2001:470:abcd:ef::1为前面的REMOTE_IP6，如果能通就说明配置正确。 部分排错 运行脚本出现RTNETLINK answers: File exists。 检查是否添加了多个隧道，如果不想删除其他隧道，请将脚本最后一行中的default修改为$REMOTE_IP6/64 刚开始能用电脑ping通服务器地址(这里指自己的服务器)，但是过一段时间就不行了。 检查防火墙是否放通41协议(不是TCP，也不是UDP，只是个协议号)，同时不要忘记检查服务商的安全组策略。 如果无法操作防火墙，可以加一个定时任务，执行内容为前面的测试脚本。 参考链接： Tsinghua isatap Example Configurations","tags":[{"name":"IPV6","slug":"IPV6","permalink":"https://i.hstb1230.com/notes/tags/IPV6/"},{"name":"隧道","slug":"隧道","permalink":"https://i.hstb1230.com/notes/tags/隧道/"}]},{"title":"Python3保存requests的cookies","date":"2019-08-12T09:07:50.000Z","path":"2019/08/Python3保存requests的cookies.html","text":"用了几天requests后, 发现它的cookie只在本次运行脚本中有效, 这样肯定不行的. 所以要提前保存Cookie, 在下次运行脚本时使用. 目前只看到一个方法, 但是应该不止, 以后会继续补充. 使用pickle保存变量pickle-save.py123456789import pickleimport requestss = requests.Session()s.get('https://aq.qq.com/cn2/index')print(s.cookies)# 将cookies写到文件with open('cookie', 'wb') as f: pickle.dump(s.cookies, f) 恢复变量pickle-load.py12345# 从文件中读取cookieswith open('cookie', 'rb') as f: # 使用update方法或者直接赋值 s.cookies.update(pickle.load(f)) # s.cookies = pickle.load(f) 附录 pickle-save.py pickle-load.py","tags":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://i.hstb1230.com/notes/tags/日常笔记/"},{"name":"Python3","slug":"Python3","permalink":"https://i.hstb1230.com/notes/tags/Python3/"},{"name":"requests","slug":"requests","permalink":"https://i.hstb1230.com/notes/tags/requests/"},{"name":"cookie","slug":"cookie","permalink":"https://i.hstb1230.com/notes/tags/cookie/"}]},{"title":"在Python3的requests中使用自签名证书","date":"2019-07-24T03:27:31.000Z","path":"2019/07/在Python3的requests中使用自签名证书.html","text":"在requests下使用代理访问https网站时出现了错误 运行环境Python版本为3.5/3.6/3.7，requests库版本为2.21.0代理软件: Fiddler 4，监听地址为：0.0.0.0:8888. 问题描述一般情况下，我们直接访问https网页是这样的： get_https_1.py123456import requests# 声明一个Session对象s = requests.Session()# 使用该对象的get方法请求网站s.get('https://httpbin.org/user-agent') 但有时候为了抓包做分析，看看提交内容是否正确，就会用到代理 get_https_2.py12345678910111213# 声明一个Session对象s = requests.Session()# 声明一个变量存放代理信息proxies = &#123; \"http\": \"http://127.0.0.1:8888/\", \"https\": \"http://127.0.0.1:8888/\"&#125;# 使用代理的两种方法# [1] 在参数中提交代理信息s.get('https://httpbin.org/user-agent', proxies=proxies)# [2] 修改Session对象的属性s.proxies = proxiess.get('https://httpbin.org/user-agent') 然后就会出错，详细信息如下（过长，请稍微对比后自行略过）： 注： D:\\RunEnvironment\\Python36\\是python程序目录 X:/get_https_2.py是代码文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354D:\\RunEnvironment\\Python36\\python.exe X:/get_https_2.pyTraceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\contrib\\pyopenssl.py\", line 456, in wrap_socket cnx.do_handshake() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\SSL.py\", line 1915, in do_handshake self._raise_ssl_error(self._ssl, result) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\SSL.py\", line 1647, in _raise_ssl_error _raise_current_error() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\_util.py\", line 54, in exception_from_error_queue raise exception_type(errors)OpenSSL.SSL.Error: [('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')]During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 594, in urlopen self._prepare_proxy(conn) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 805, in _prepare_proxy conn.connect() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connection.py\", line 344, in connect ssl_context=context) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 347, in ssl_wrap_socket return context.wrap_socket(sock, server_hostname=server_hostname) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\contrib\\pyopenssl.py\", line 462, in wrap_socket raise ssl.SSLError('bad handshake: %r' % e)ssl.SSLError: (\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",)During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\adapters.py\", line 449, in send timeout=timeout File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 638, in urlopen _stacktrace=sys.exc_info()[2]) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\util\\retry.py\", line 399, in increment raise MaxRetryError(_pool, url, error or ResponseError(cause))urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='httpbin.org', port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",),))During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"X:/get_https_2.py\", line 8, in &lt;module&gt; r = s.get('https://httpbin.org/user-agent') File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 546, in get return self.request('GET', url, **kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 533, in request resp = self.send(prep, **send_kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 646, in send r = adapter.send(request, **kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\adapters.py\", line 514, in send raise SSLError(e, request=request)requests.exceptions.SSLError: HTTPSConnectionPool(host='httpbin.org', port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",),))Process finished with exit code 1 大概说是证书校验错误(certificate verify failed)，于是百度一番 初步解决 在get/post等请求方法中加上参数verify=False 1s.get(url, verify=False) 或修改整个session的属性 1s.verify = False 彻底解决虽然使用前面的做法后程序不出错了，但是每次通过代理访问https网站时又会出现警告: D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py:847: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings 大概意思是「现在创建的是未经验证的https请求，强烈建议添加证书验证」 同时也给了个文档地址，大概是要装certifi库，然后再做一些操作，不过折腾了一会也没搞懂，就放弃了. 后面去Google搜索，看到Stack Overflow上有个问题类似的帖子，阅读了下发现与我的需求差不多： 1requests.get(\"https://www.python.org\", proxies=&#123;\"http\": \"http://127.0.0.1:8888\", \"https\":\"http:127.0.0.1:8888\"&#125;,verify=r\"FiddlerRoot.pem\") I've got to change .cer(DER format) file into .pem(PEM format). And I realized cert parameter was not that I wanted to use. The code above is a solution for me.fx-kirinstackoverflow 后续补充: execute command in a console openssl x509 -inform der -in FiddlerRoot.cer -out FiddlerRoot.pem 大致意思是verify参数可以设置成证书文件的路径，但问题出在需要的是pem格式，而Fiddler导出的证书是cer文件. 所以要使用OpenSSL转换，命令为openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] [FiddlerRoot.cer]为你从Fiddler中导出的cer文件路径(相对或绝对路径) [FiddlerRoot.pem]为导出的pem文件路径. 因为Windows不带OpenSSL程序，为此又特地摸索了几天，头大 执行命令后，将pem文件路径传给verify，或者修改整个Session对象的verify属性即可. 同时，也可以给verify赋值pem文件的所在目录，但要先用OpenSSL附带的c_rehash.pl处理该文件夹. get_https_3.py12345678910111213141516import requests# 声明一个Session对象s = requests.Session()# 修改代理信息s.proxies = &#123; \"http\": \"http://127.0.0.1:8888/\", \"https\": \"http://127.0.0.1:8888/\"&#125;# 设置自定义证书# # 假设证书在代码目录下的cert文件夹里，文件名为FiddlerRoot.pem# # 直接使用相对路径s.verify = r'cert\\FiddlerRoot.pem'# # 如果使用了c_rehash.pl对cert文件夹做了处理，可以修改为如下一行代码s.verify = r'cert's.get('https://httpbin.org/user-agent') 不过这工具(实际上是Perl代码文件)不怎么适应Windows，识别不到openssl路径，所以对它稍作修改，有需要可以在附件下载. 用了这个方法几天，发现还有个奇怪的坑，就是转换的pem文件只能在本次打开的Fiddler中使用，第二次打开Fiddler就会证书错误，但是导入到Windows证书管理后，浏览器是可以一直使用的，所以不知道怎么回事，有需要再摸索吧. 最后补充下这个工具的使用方法吧： 首先需要电脑中要安装perl、openssl并配置环境变量，然后在cmd中执行perl c_rehash.pl pem文件所在目录，如果pem文件所在目录下多出了一个不明代码文件，那么就说明成功了。 二次补充（这次应该是真的最后一次了）： 今天给FTP服务器上TLS的时候，发现openssl生成的证书有效期只有一天，后来查了下，发现在参数列表中加个-days [天数]即可修改有效期.因此也推测转换出来的pem证书也只有一天有效期，而我往往是开一天的Fiddler后才关，所以等我第二次打开Fiddler，也就是第二天的时候，证书自然失效了。所以转换命令应为openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] -days [3650] 附录本文代码(附件): get_https_1.py get_https_2.py get_https_3.py c_rehash.pl 参考链接: REQUESTS库的文档高级用法 Python Requests and Burp Suite How to capture python https traffic in fiddler? - Stack Overflow How to capture python SSL(HTTPS) connection through fiddler2 - Stack Overflow","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb1230.com/notes/tags/HTTPS/"},{"name":"Python3","slug":"Python3","permalink":"https://i.hstb1230.com/notes/tags/Python3/"},{"name":"requests","slug":"requests","permalink":"https://i.hstb1230.com/notes/tags/requests/"},{"name":"proxy","slug":"proxy","permalink":"https://i.hstb1230.com/notes/tags/proxy/"}]},{"title":"JavaScript取网址请求串","date":"2019-02-03T17:23:27.000Z","path":"2019/02/JavaScript取网址请求串.html","text":"准确来说应该是取域名后面的那串文本，但是实在是不知道叫什么。 方法：使用substring截取url中在域名后面的文本。 12345678function getQuery() &#123; var href = window.location.href; // url var host = window.location.host; // 域名 var query = href.substring( href.lastIndexOf(host) + host.length, // 要加长度 href.length ); return query;&#125; 效果： 12当前URL：http://localhost/manage/?test#123456调用结果：/manage/?test#123456 使用场景：登录状态失效或不存在时，在跳转到登录页前获取当前功能页地址并传递给接口，登录后成功后跳转至该页面，优化用户体验。","tags":[{"name":"日常笔记","slug":"日常笔记","permalink":"https://i.hstb1230.com/notes/tags/日常笔记/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://i.hstb1230.com/notes/tags/JavaScript/"}]},{"title":"升级HTTPS需要注意的坑","date":"2017-10-12T16:21:26.000Z","path":"2017/10/升级HTTPS需要注意的坑.html","text":"没错，就是我，又来水文章的我。 但是今天应该算是来放干货的。 应该来说，从最开始的有个小绿锁到防运营商的广告污染，HTTPS 已经成了未来站点的发展趋势，那么对应的，网上一定也会出现各种眼花缭乱的教程(包括我的，虽然我之前根本没写过的说)但这些教程总是缺点东西，我写这篇文章的目的就是为了补充一下一些坑。 那啥，怎么HTTP → HTTPS就不说了哈，我只是想说下升级到 HTTPS 后需要注意的地方。 众所周知，HTTPS 网页里面不能引用 HTTP 资源，不然会被浏览器标记为不安全，(也就是没有小绿锁，好好的逼格就这样被吃了)，那么，相信很多教程会建议你们把带有http://的内容替换成https://或者//，再高端一点的，会教你们用 世界上最好的 PHP 写个代理程序，然后配合 JavaScript 食用，这样做大概是因为某些资源站点不支持 HTTPS 。 而我就不一样了，作为一个经常长草的静态博客，我既不太想不能用拍簧片 PHP，又想看到小绿锁，那我总得找个折中的办法： 在&lt;head&gt;标签下加上这样一行&lt;meta&gt;标签，就可以让浏览器强制使用 HTTPS 协议获取网页引用的所有资源： 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt; 千万不要和我说你不知道怎么加(手动再见) 下面是效果对比： 添加前的网络访问情况 添加后的网络访问情况，敢跟我说这是审查元素改出来的效果，请主动把头伸过来，让我给你加个五毛特效 有几点得强调下： 我没测试过各大浏览器的兼容情况，据我临时百度了解，这是 W3C 在 2012 年发布的新标准里的一个内容，但我想，是个现代浏览器应该都支持。 不要以为这个 META 标签是万能的，万一你引用的资源站点只支持 HTTP 协议访问，那么不好意思，该丢的只能丢了，建议有条件的还是用代理方式获取对应资源吧。 来自咸鱼的话： 资源链接最好用//，因为浏览器会自动识别当前协议(HTTP/HTTPS)，不然以后出个新的协议又要改，那就又要接着改。 关于HTTPS网页里不能引用HTTP资源这点可能会有些争议，我印象里前两年的Chrome好像是这样。不要奇怪这个发布时间和更新，文章确实是那个时候开始写的，只不过今天(2018/04/02)才写完，原谅我的懒癌 希望终有一天，所有的站点都能上HTTPS吧","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb1230.com/notes/tags/HTTPS/"}]},{"title":"用PHP取图像颜色","date":"2017-10-05T17:26:38.000Z","path":"2017/10/用PHP取图像颜色.html","text":"对 将图片转为Html网页 以及发布在Github的 img2html 项目代码的一些补充 对于拥有丰富的扩展和类库的PHP来说，提取图像颜色并非难事，使用自带的GD扩展，借助其中的函数即可完成。 首先，我们需要借助 imagecreatefrom 开头的函数导入图像，(怎么获取数据就自己来吧，file_get_contents 之类的) 官方文档列出了以下函数： imagecreatefrombmp imagecreatefromgd2 imagecreatefromgd2part imagecreatefromgd imagecreatefromgif imagecreatefromjpeg imagecreatefrompng imagecreatefromstring imagecreatefromwbmp imagecreatefromwebp imagecreatefromxbm imagecreatefromxpm 这些函数均只有一个参数，但需要注意的是， 除了 imagecreatefromstring 函数外，其余函数的参数需要为文件的本地路径或网络地址，而 imagecreatefromstring 函数的参数只能为文件数据，并且 imagecreatefromstring 函数可以解析 JPEG，PNG，GIF，WBMP 和 GD2 图片文件。 这里用 png图片 做解析，因此先 1$img = imagecreatefrompng('https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396'); 然后取图像的宽度与高度： 12$Y = imagesy($i); //取高度$X = imagesx($i); //取宽度 如果我们要计算图像颜色的平均值，那么: 12$rgb = 0; //用于统计颜色总值$n = $X * $Y; //用于记录像素点数量 然后先创建一个遍历行的循环： 12for ($y=0; $y&lt;$Y; $y++) &#123; //循环行&#125; 再创建一个遍历列的循环，但是需要嵌套在行里，即： 1234for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 &#125;&#125; 这时借助 imagecolorat 函数，取出指定像素点的颜色值(十进制)： 12345for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 $rgb += imagecolorat($i,$x,$y); //取出点($x,$y)的颜色值后，叠加计算 &#125;&#125; 然后计算图像的平均颜色值： 1$rgb = $rgb / $n; 得到的颜色值是 10进制 的，如果要转换成 16进制，可以借助函数 dechex。 最后，记得释放资源： 1imagedestroy($i);","tags":[{"name":"PHP","slug":"PHP","permalink":"https://i.hstb1230.com/notes/tags/PHP/"},{"name":"图像操作","slug":"图像操作","permalink":"https://i.hstb1230.com/notes/tags/图像操作/"}]},{"title":"配置Notepad++的c语言运行脚本","date":"2017-10-04T17:41:36.000Z","path":"2017/10/配置Notepad++的c语言运行脚本.html","text":"上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。 因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。 后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。 然后上网查方法，看到的教程都是这样给的： 复制以下代码，取名编译C：cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT 复制以下代码，取名运行C：cmd /c &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT 仔细分析下，就会发现调试需要分两步操作，有点麻烦 所以我改了一下代码，将编译运行一步到位： 1cmd /k gcc -o \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" &amp;&amp; \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" &amp; PAUSE &amp; EXIT 不过这样做有一个缺点，就是编译出错时，仍然会运行一次程序，如果之前又编译成功过，那么就有可能会误导你。","tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://i.hstb1230.com/notes/tags/环境配置/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://i.hstb1230.com/notes/tags/Notepad/"},{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C语言/"}]}]