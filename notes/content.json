[{"title":"PAT(Base) 1073 多选题常见计分法","date":"2020-02-28T22:23:37.000Z","path":"2020/02/PAT-Base-1073-多选题常见计分法.html","text":"题目链接: https://pintia.cn/problem-sets/994805260223102976/problems/994805263624683520 题目描述批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。 输入格式输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为(选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出Too simple。 输入样例13 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (3 b d e) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (1 c) (4 a b c d) 输出样例13.5 6.0 2.5 2 2-e 2 3-a 2 3-b 输入样例22 2 3 4 2 a c 2 5 1 b (2 a c) (1 b) (2 a c) (1 b) 输出样例25.0 5.0 Too simple 解题 因为通宵肝题, 所以不太能保证写清楚思路, 见谅.这题第一眼让我想起1058, 本以为挺简单, 只是加了个统计选项, 直到写完v1测了下样例1才发现too young too simple. 难点 因为选项数据是(数量 选项1, 选项2...), 所以多了一步解析问题,我采用的办法是先getline, 再查找(的位置, 然后用sscanf读, 因为选项只有a-e, 所以每次把位置+2就能排除干扰数据了(指())因为最开始比较蜜汁自信, 就没有看1058copy一下, 所以又被坑了一次, 在1058里, 我用的是string类的find方法, 异曲同工. 错误数据有两个键, 分别是题目编号和选项编号, 排序倒是不难处理, 麻烦的是正确指向对应数据.可以先构建一个结构体存放两个键, 然后用map, 但这样要多写一个变量, 嫌麻烦就没采用;我的做法是将这两个键组合成浮点数, 也就是题目编号做整数部分, 选项编号做小数部分. 错误选项的意思是没选全时漏选的正确选项 + 选的错误选项, [1]测样例1的时候感觉很奇怪, 明明b是第3题的正确选项, 为什么会是错误选项, 后面看到其他人的解析才懂. 然后就很坑爹了, 这意味着我可能要重写代码, 但在思考后, 我发现并不用,既然是没选全时漏选的正确选项, 那就把正确选项也当成错误选项来统计, 初始的错误次数即学生人数, 选对一次就把错误次数减一, 最后得到的就是漏选的人数, 即该正确选项的错误次数. 这道题真正的做法是用异或之类的位运算, 对这块不是特别懂, 就不解释了, 有兴趣的看柳神的题解[2], 要简单很多. Code of itanswer-with-difficultview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef struct { int full_score, answer_count, true_answer_count; vector&lt;char&gt; true_answer;} question;typedef pair&lt;double, int&gt; mp;bool cmp(mp a, mp b) { if(a.second != b.second) return a.second &gt; b.second; else if((int)a.first != (int)b.first) return (int)a.first &lt; (int)b.first; else return ((int)(a.first * 10) % 10) &lt; ((int)(b.first * 10) % 10);}void print_wrong(map&lt;double, int&gt; wrong) { vector&lt;mp&gt; mps(wrong.begin(), wrong.end()); sort(mps.begin(), mps.end(), cmp); int len = mps.size(); printf(\"====\\n\"); for(int i = 0; i &lt; len; i++) { printf(\"%d %d-%c\\n\", mps[i].second, (int)mps[i].first, ('a' + (int)(mps[i].first * 10) % 10));// printf(\"%d-%c\\n\", (int)mps[i].first, ('a' + (int)(mps[i].first * 10) % 10)); } printf(\"====\\n\");}int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;question&gt; q(m); map&lt;double, int&gt; wrong; for(int i = 0; i &lt; m; i++) { cin &gt;&gt; q[i].full_score &gt;&gt; q[i].answer_count &gt;&gt; q[i].true_answer_count; q[i].true_answer.resize(q[i].true_answer_count); for(int j = 0; j &lt; q[i].true_answer_count; j++) { cin &gt;&gt; q[i].true_answer[j]; wrong[(i + 1 + 0.1 * (q[i].true_answer[j] - 'a'))] = n; } }// print_wrong(wrong); string all_answers; const char * loc; int choose_count, flag; char choose; double sum; for(int i = 0; i &lt;= n; i++) { getline(cin, all_answers); if(all_answers == \"\") continue; loc = all_answers.c_str(); sum = 0; for(int j = 0; j &lt; m; j++) { flag = 0; while(*loc != '(') loc++; loc++; sscanf(loc, \"%d\", &amp;choose_count);// printf(\"%d \", choose_count); for(int k = 0; k &lt; choose_count; k++) { loc += 2; sscanf(loc, \"%c\", &amp;choose);// printf(\"%c \", choose); if(find(q[j].true_answer.begin(), q[j].true_answer.end(), choose) != q[j].true_answer.end()) { wrong[(j + 1 + 0.1 * (choose - 'a'))]--; if(flag &gt;= 0) flag++; } else { flag = -1; // Maybe Input Invaild Choose if((choose - 'a') &lt;= q[j].answer_count) wrong[(j + 1 + 0.1 * (choose - 'a'))]++; } } if(flag == -1) { // have wrong } else if(flag == q[j].true_answer_count) { // true sum += q[j].full_score; } else { // part of true sum += 0.5 * q[j].full_score; }// printf(\"%d %.1f\\n\", flag, sum); }// print_wrong(wrong); printf(\"%.1f\\n\", sum); } vector&lt;mp&gt; mps(wrong.begin(), wrong.end()); sort(mps.begin(), mps.end(), cmp); int len = mps.size(); flag = 1; for(int i = 0; i &lt; len; i++) { if(i == 0 &amp;&amp; mps[i].second &lt;= 0) { flag = 0; break; } if(i &gt; 0 &amp;&amp; mps[i].second != mps[i - 1].second) break; printf(\"%d %d-%c\\n\", mps[i].second, (int)mps[i].first, ('a' + (int)(mps[i].first * 10) % 10)); } if(flag == 0) printf(\"Too simple\");} Code of 10581058-选择题view raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct { int full; int num; int true_ans; vector&lt;char&gt; ans; int id; int wrong;} problem;bool cmp(problem a, problem b) { if(a.wrong == b.wrong) return a.id &lt; b.id; return a.wrong &gt; b.wrong;}void printProblems(vector&lt;problem&gt; p) { int len = p.size(); for(int i = 0; i &lt; len; i++) { printf(\"%d: %d\\n\", p[i].id, p[i].wrong); }}int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;problem&gt; p(m); for(int i = 0; i &lt; m; i++) { cin &gt;&gt; p[i].full &gt;&gt; p[i].num &gt;&gt; p[i].true_ans; p[i].id = i + 1; p[i].wrong = 0; p[i].ans.resize(p[i].true_ans); for(int j = 0; j &lt; p[i].true_ans; j++) cin &gt;&gt; p[i].ans[j]; sort(p[i].ans.begin(), p[i].ans.end()); } string ans_string; const char * tmp; int loc, num; vector&lt;char&gt; choose; vector&lt;int&gt; score(n + 1, 0); for(int i = 0; i &lt;= n; i++) { getline(cin, ans_string); if(ans_string == \"\") continue; loc = 0; tmp = ans_string.c_str(); for(int j = 0; j &lt; m; j++) { loc = ans_string.find('(', loc) + 1; sscanf(tmp + loc, \"%d\", &amp;num); choose.resize(num); for(int k = 0; k &lt; num; k++) { sscanf(tmp + loc + (k + 1) * 2, \"%c\", &amp;choose[k]); } sort(choose.begin(), choose.end()); if(choose != p[j].ans) p[j].wrong++; else score[i] += p[j].full; } } for(int i = 1; i &lt;= n; i++) { cout &lt;&lt; score[i] &lt;&lt; endl; } sort(p.begin(), p.end(), cmp);// printProblems(p); if(p[0].wrong == 0) cout &lt;&lt; \"Too simple\" &lt;&lt; endl; else { printf(\"%d %d\", p[0].wrong, p[0].id); for(int i = 1; i &lt; p.size(); i++) { if(p[i].wrong != p[i - 1].wrong) break; printf(\" %d\", p[i].id); } }} 参考链接[1] https://blog.csdn.net/CV_Jason/article/details/79587893[2] https://www.liuchuo.net/archives/4216","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"PAT(Base) 1055 集体照","date":"2020-02-20T15:35:43.000Z","path":"2020/02/PAT(Base)-1055-集体照.html","text":"题目链接: https://pintia.cn/problem-sets/994805260223102976/problems/994805272021680128 题目描述拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下： 每排人数为 N /K（向下取整），多出来的人全部站在最后一排； 后排所有人的个子都不比前排任何人矮； 每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）； 每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）； 若多人身高相同，则按名字的字典序升序排列。这里保证无重名。 现给定一组拍照人，请编写程序输出他们的队形。 输入格式每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤10^4，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。 输出格式输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。 输入样例10 3 Tom 188 Mike 170 Eva 168 Tim 160 Joe 190 Ann 168 Bob 175 Nick 186 Amy 160 John 159 输出样例Bob Tom Joe Nick Ann Mike Eva Tim Amy John 解题思路解析按照题目意思, 我们需要存入身高和姓名信息, 1234typedef struct &#123; string name; int high;&#125; people; 因为要排序后再分成K组, 最高的人在最后一排, 但是是先输出最后一排的人,所以按照身高做递减排序, 同身高时, 需要根据名字做升序排列, 比较函数并不难写 123456bool cmp(people a, people b) &#123; if(a.high &#x3D;&#x3D; b.high) return a.name &lt; b.name; else return a.high &gt; b.high;&#125; 以题目给的demo为例, 人员经过排序后, 顺序如下表所示: name height Joe 190 Tom 188 Nick 186 Bob 175 PRINT Bob Tom Joe Nick Mike 170 Ann 168 Eva 168 PRINT Ann Mike Eva Amy 160 Tim 160 John 159 PRINT Tim Amy John 每排最高的人要站在中间位置(m / 2 + 1, 向下取整), 假设每排的第一个人下标是0, 那么其实就等于m / 2. 而其他人要依次”先右后左”的站在最高人两侧, 但因为要面对这些人, 所以实际上是”先左后右”. 因为每排人员位置的分布不是特别规律, 所以一开始有点想再加一个字符串数组存放名字, 但是后面觉得太浪费空间, 就没有采用这种方法(虽然简单). 因为脑子一时糊涂, 把K当成每排人数, 只过了三个点, 以为是写法有问题, 就重新推理一遍, 得出第二种方法, 还是只过前三点(因为K), 后面看了下网友写法[1]才想起, 纠正了下, 再次提交, 法1和法2均通过. 法1 name height Joe 190 Tom 188 Nick 186 Bob 175 PRINT Bob | Tom | Joe | Nick Mike 170 Ann 168 Eva 168 PRINT Ann | Mike | Eva 观察人员分布位置可以看出, 中间人(最高的人, 斜体文本)两侧的数字总在距离上差2, 当排人数为偶数时, 第一个人就是最矮的人; 当排人数为奇数时, 第一个人就是第二矮的人. 输出完中间人左边的部分(灰背景文本), 再看右边的部分(粗体蓝字), 右边人的身高是降序排列的, 而且不管是偶数还是奇数, 和中间人在距离上都差2. Codeanswer-1view raw12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct { string name; int high;} people;bool cmp(people a, people b) { if(a.high == b.high) return a.name &lt; b.name; else return a.high &gt; b.high;}void printPeople(vector&lt;people&gt; p) { printf(\"----\\n\"); for(int i = 0; i &lt; p.size(); i++) { printf(\"%s %d\\n\", p[i].name.c_str(), p[i].high); } printf(\"----\\n\");}int main() { int N, K; cin &gt;&gt; N &gt;&gt; K; int length = N / K; vector&lt;people&gt; p(N); for(int i = 0; i &lt; N; i++) { cin &gt;&gt; p[i].name &gt;&gt; p[i].high; } sort(p.begin(), p.end(), cmp);// printPeople(p); int every = N / K; int m = every + (N % K); int highest, center, j = 0, begin; for(int i = 0; i &lt; N; i++) { if(j == 0) { if(i &gt; 0) printf(\"\\n\");// cout &lt;&lt; m &lt;&lt; endl; highest = i; center = m / 2; begin = i + m - 1 - (m % 2); } else { printf(\" \"); } if(j &lt; center) { printf(\"%s\", p[begin].name.c_str()); begin -= 2; } else if(j == center) { printf(\"%s\", p[highest].name.c_str()); begin = highest + 2; } else if(j &gt; center) { printf(\"%s\", p[begin].name.c_str()); begin += 2; } if(++j == m) { j = 0; if(m != every) m = every; } }} 法2 name height Joe 190 Tom 188 Nick 186 Bob 175 PRINT Bob | Tom | Joe | Nick Mike 170 Ann 168 Eva 168 PRINT Ann | Mike | Eva 重新观察下位置分布, 可以发现: 当排人数为偶数时先输出最后一个人; 为奇数时先输出倒数第二个人, 隔着按身高排列逆序输出下一个人. 这样就输出完中间人的左边部分(灰背景文本), 而且不管是奇数还是偶数, 输出左边部分时一定不会输出中间人(每排只有一个人的情况另说), 再看右边部分(加粗蓝文本), 可以发现第一个就是中间人, 同样还是隔着, 但按身高排列正序输出下一个人, 这样就把右边部分都输出了. 法2应该是最好理解也最简单的. Codeanswer-2view raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct { string name; int high;} people;bool cmp(people a, people b) { if(a.high == b.high) return a.name &lt; b.name; else return a.high &gt; b.high;}void printPeople(vector&lt;people&gt; p, int K) { printf(\"----\\n\"); int every = p.size() / K; int m = p.size() % K + every; for(int i = 0; i &lt; p.size(); i++) { printf(\"%s %d\\n\", p[i].name.c_str(), p[i].high); if(--m == 0) { m = every; printf(\"\\n\"); } } printf(\"----\\n\");}int main() { int N, K; cin &gt;&gt; N &gt;&gt; K; int length = N / K; vector&lt;people&gt; p(N); for(int i = 0; i &lt; N; i++) { cin &gt;&gt; p[i].name &gt;&gt; p[i].high; } sort(p.begin(), p.end(), cmp);// printPeople(p, K); int every = N / K; int m = every + N % K, flag; for(int i = 0; i &lt; N; i += m, m = every) { flag = 0; for(int j = (i + m - 1) - m % 2; j &gt;= i; j -= 2) { if(flag++ &gt; 0) printf(\" \"); printf(\"%s\", p[j].name.c_str()); }// printf(\" |\"); for(int j = i; j &lt; i + m; j+= 2) { if(flag++ &gt; 0) printf(\" \"); printf(\"%s\", p[j].name.c_str()); } printf(\"\\n\"); }} 参考链接[1] https://www.jianshu.com/p/eee6c21b1387","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"PAT(Base) 1052 卖个萌","date":"2020-02-17T21:30:25.000Z","path":"2020/02/PAT(Base)-1052-卖个萌.html","text":"题目链接: https://pintia.cn/problem-sets/994805260223102976/problems/99480527388395110 题目描述萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： [左手]([左眼][口][右眼])[右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @\\/@。 输入样例[╮][╭][o][~\\][&#x2F;~] [&lt;][&gt;] [╯][╰][^][-][&#x3D;][&gt;][&lt;][@][⊙] [Д][▽][_][ε][^] ... 4 1 1 2 2 2 6 8 1 5 5 3 3 4 3 3 2 10 3 9 3 输出样例╮(╯▽╰)╭ &lt;(@Д&#x3D;)&#x2F;~ o(^ε^)o Are you kidding me? @\\&#x2F;@ 解题思路解析 前三行分别是手、眼、口的符号集，每个符号头尾为[和],可以先标记前一个[的位置, 找到]后再截取出符号. 用数组存储符号集, 也方便后面判断序号是否合法. 文本中可能会出现干扰文本, 比如第三行的... 坑点 Dev-C++没法正常输出某些颜文字的问题, 题目描述不清楚, 或者说是样例不全, 可能会因此疏忽而出现段错误, 疏忽了C语言字符串中, 单个\\表示转义, 无法通过测试点. 输出文本包含一对括号. 不能用s[i]判断是否到字符串结尾, 而应该用.length方法. 如果会正则的话, 这题应该会更简单一些. Code因为有一些调试性质的代码, 所以会略乱. answerview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void get_face(string s, vector&lt;string&gt; &amp; face) { face.clear(); int start; int len = s.length(); for(int i = 0; i &lt; len; i++) { if(s[i] == '[') start = i + 1; else if(s[i] == ']') { // cout &lt;&lt; start &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; face.push_back(s.substr(start, i - start)); } }}void print_face(vector&lt;string&gt; face) { cout &lt;&lt; face.size() &lt;&lt; endl; for(int i = 0; i &lt; face.size(); i++) { if(i &gt; 0) cout &lt;&lt; \" \"; cout &lt;&lt; face[i]; } cout &lt;&lt; endl;}int main() { string a, b, c; getline(cin, a); getline(cin, b); getline(cin, c);// cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl &lt;&lt; c &lt;&lt; endl; vector&lt; vector&lt;string&gt; &gt; face(3); get_face(a, face[0]); // hand get_face(b, face[1]); // eye get_face(c, face[2]); // mouth// print_face(face[0]);// print_face(face[1]);// print_face(face[2]); int n; cin &gt;&gt; n; int q, w, e, r, t; // left_hand, left_eye, mouth, right_eye, right_hand for(int i = 0; i &lt; n; i++) { cin &gt;&gt; q &gt;&gt; w &gt;&gt; e &gt;&gt; r &gt;&gt; t; if( q &lt;= 0 || w &lt;= 0 || e &lt;= 0 || r &lt;= 0 || t &lt;= 0 || q &gt; face[0].size() || w &gt; face[1].size() || e &gt; face[2].size() || r &gt; face[1].size() || t &gt; face[0].size() ) { printf(\"Are you kidding me? @\\\\/@\\n\"); } else { printf( \"%s(%s%s%s)%s\\n\", face[0][q - 1].c_str(), face[1][w - 1].c_str(), face[2][e - 1].c_str(), face[1][r - 1].c_str(), face[0][t - 1].c_str() ); } }}","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言计算素数","date":"2020-02-03T17:27:55.000Z","path":"2020/02/C语言计算素数.html","text":"上次疏忽了, 把这篇空白文也打包发布了 其实也没什么好写的, 在标题上也特别纠结. 首先, 素数的定义[1]: 质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。 假定现在有一数N, 那么最无脑的判断方法, 当然是把2到N - 1都除一遍, 只要有一个能整除, 就不是素数. 但这样太费时了(时间复杂度为N - 2), 仔细思考下就会发现, 多除了一倍不必要的数字,也就是说, 应该要从2除到N/2. 不是特别严谨但是能懂的论证: 假设N = 1000, 当除数到500之后, 也就是到N一半后, 商值范围为`[2, 1), 也就是说, 接着往下除, 商不可能为整数, 等于做了无意义的求解. 修改为从2除到N / 2后, 时间复杂度降至N / 2 - 1. 但是还能优化, 假设N = 100, 也就是要依次除以2,3,4,5,6,7,8,9,10, … ,50.仔细思考, 会发现这里会有两个问题:I. 除以2和除以50重复.II. 4,6,8等是可以被2整除的数. 第 I 点说明除数范围不够严谨, 但无论如何纠正, 都无法用普通的数学表示绕过4这个坑. 能绕过但看起来奇怪的严谨范围是[2, max(3, N / 2 - 1)), N &gt; 2. 还有一种不太懂但同样可行的办法是将范围缩小到[2, sqrt(N) + 1) 第 II 点可以用埃拉托斯特尼筛法(简称埃筛法)解决: 从2开始, 将其倍数剔除, 再剔除下一个数3的倍数, 直到没数能剔除. 剔除倍数应该很好理解, 因为素数的定义就是只能被1和本身整除,至于为什么直接认定下一个数是素数, 剔除其倍数, 因为这个数如果不是素数, 那么一定能被前面的某一素数整除.(听起来可能有点绕, 建议自行推算) 这个做法在求指定范围内的素数很好用, 先上个代码 埃拉托斯特尼筛法view raw12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() { bool a[101]; fill_n(a, 101, true); for(int i = 2; i &lt; 101; i++) { if(a[i] == false) continue; for(int j = 2 * i; j &lt; 101; j += i) a[j] = false; } for(int i = 2; i &lt; 101; i++) { if(a[i]) printf(\"%d \", i); }} 输出 12 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 补充一个注意点(因为网页不能同时显示两种文本编码, 所以写在这里): 将所有元素赋值最好用fill_n或者memset, 不能用bool a[N] = {true};,否则只有第一个元素为true, 但赋值false是全false的(比较神奇的设计)[4] {false}似乎对二维数组无效, 而fill_n不能赋值二维数组, 建议使用memset. fill_n可以直接使用, memset需要#include &lt;memory.h&gt;(注意不是cmemory, 没这个库) 将求解过程函数化 埃拉托斯特尼筛法(函数化)view raw12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void getPrime(vector&lt;int&gt; &amp; prime, int n) { if(n &lt; 2) return; prime.clear(); vector&lt;bool&gt; isPrime(n + 1, true); for(int i = 2; i &lt;= n; i++) { if(isPrime[i]) { prime.push_back(i); for(int j = 2 * i; j &lt;= n; j += i) isPrime[j] = false; } }}int main() { vector&lt;int&gt; prime; getPrime(prime, 10000); printf(\"%d\\n\", prime.size()); for(vector&lt;int&gt;::iterator it = prime.begin(); it != prime.end(); it++) { printf(\"%d \", *it); }} 但这个写法还是有点小问题 —- 会重复赋值, 比如2和3的公倍数6, 所以就有了欧拉筛法. 简单来说, 欧拉筛法就是限制赋值, 只需要数被第一个能整除的素数剔除即可. 欧拉筛法view raw1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void get_prime(vector&lt;int&gt; &amp; prime, int n) { if(n &lt; 2) return; prime.clear(); vector&lt;bool&gt; is_prime(n + 1, true); for(int i = 2; i &lt;= n; i++) { if(is_prime[i]) { prime.push_back(i); } for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; j++) { is_prime[ i * prime[j] ] = false; if(i % prime[j] == 0) break; } }}int main() { vector&lt;int&gt; prime; get_prime(prime, 100); for(vector&lt;int&gt;::iterator it = prime.begin(); it != prime.end(); it++) { printf(\"%d \", *it); }} 相对于埃筛法, 其变动代码在于10~16行 (别吐槽缩进, 因为解析器有毒) 欧拉筛法view raw1234567if(is_prime[i]) { prime.push_back(i); } for(int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; j++) { is_prime[ i * prime[j] ] = false; if(i % prime[j] == 0) break; } push_back只是将其加入素数列表. 不再是遇到素数时才剔除, 而是剔除当前这个数与每个素数的积,若能整除素数, 则不再剔除该数与下个素数的积. i * prime[j] &lt;= n用来防止数组越界, 或者理解成不判断计算范围外的数. 突然意识到我不该在C++混用驼峰风格hh(C++方法名和变量都是a_b, 而不是aB) 计算20以内的素数, 每轮剔除数信息. 如果不限制计算范围, 或者说计算所有素数, 将会是这种情况(这里限制查看范围到50) 不过, 如果只是想判断这个素数是不是素数,只要把找到的素数缓存下来, 判断当前这个数是否能整除所有素数, 简易判断法view raw123456789101112bool is_prime(int &amp; n) { if(n &lt; 2) return true; static int prime[10000] = {2}; static int t = 1; int k = 0; int end = n / 2; for(int i = prime[t - 1] + 1; i &lt;= end; i++) { for(int j = k; j &lt; t; j++) { if(n % prime[j] == 0) return false; if(j + 1 == t &amp;&amp; i % prime[j] != 0) { k = t; prime[t++] = i; 注意保存素数列表的prime数组大小, 如果数值很大, 也要修改, 否则会发生溢出. static可以去掉, 设置成静态数组只是能更快的运行完这份代码,注意: 这份代码是依次判断2~10000有哪些是素数, 没有缓存素数时, 每判断一个数, 都要生成一次素数列表,而不像上份源码那样, 一次性生成2~10000的素数, 所以运行会慢. 最开始运行时间慢好多, 经过不断优化后总算和前面几种方法差不太多, 吐血. 最后, 送上一个超简易版, 也就是傻瓜版. 超简易版view raw1234567bool is_prime(const int n) { int end = sqrt(n) + 1; for(int i = 2; i &lt; end; i++) { if(n % i == 0) return false; } return true;} 附上时间差异, 反正我的内心是懵圈的. 不过, 没准把埃式和欧拉去掉vector可能会再快一些吧. 有精力再咕了. 写在最后: 其实是刷题目(1013 数素数)的时候遇到的一个知识点, 本来是想分享一下思路, 不知不觉写到这了. 分享下我的丢人写法. 1013_数素数view raw12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(const int n) { int end = sqrt(n) + 1; for(int i = 2; i &lt; end; i++) { if(n % i == 0) return false; } return true;}int getNextPrime(const int startPrime) { int prime = startPrime; if(prime == 2) prime = 3; else for(int i = prime + 2; ; i += 2) { if(isPrime(i)) { prime = i; break; } } return prime;}int main() { int m, n; cin &gt;&gt; m &gt;&gt; n; int prime = 2; for(int i = 1; i &lt; m; i++) { // printf(\"%d:%d\\n\", i, prime); prime = getNextPrime(prime); } int flag = 0; for(int i = m; i &lt;= n; i++) { // printf(\"%d:%d\\n\", i, prime); if(++flag % 10 != 1) cout &lt;&lt; ' '; cout &lt;&lt; prime; if(flag % 10 == 0) cout &lt;&lt; endl; prime = getNextPrime(prime); }} 脑壳有点大, 如果有想起了什么再补充. 参考链接:[1] https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0[2] https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95[3] https://www.jianshu.com/p/7867517826e7[4] https://blog.csdn.net/u012223913/article/details/51176071","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"}]},{"title":"C语言控制分隔符输出","date":"2020-02-03T15:35:03.000Z","path":"2020/02/C语言控制分隔符输出.html","text":"我又来丢人了.jpg 目前只遇上(或者说记得)这_种, 有更多情况再补充吧 以空格分隔数据这个无脑, 每次输出数据的时候多带个空格就好.诸如: printf(&quot;%d &quot;, data[i]); cout &lt;&lt; data[i] &lt;&lt; &#39; &#39;; 以空格分隔数据，但行末不得有多余空格两种思路, 但至少先把数据和分隔符单独输出.都是借助循环的当前位置 先输出数据, 再控制输出分隔符1234for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; data[i]; if(i + 1 &lt; n) cout &lt;&lt; ' ';&#125; 先控制输出分隔符, 后直接输出数据1234for(int i = 0; i &lt; n; i++) &#123; if(i &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; data[i];&#125; 个人觉得后者会好一点, 毕竟少了n次加法运算 以空格分隔数据，并且每行只输出10个数据依旧可以参考上者 12345for(int i = 0; i &lt; n; i++) &#123; if(i % 10 &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; data[i]; if(i % 10 == 9) cout &lt;&lt; endl;&#125; 不过, 对于i不是从0开始的情况, 就要额外计算i的相对位置了, 即再减去起点 12345for(int i = 5; i &lt; n; i++) &#123; if(i &gt; 5) cout &lt;&lt; ' '; cout &lt;&lt; data[i]; if((i - 5) % 10 == 9) cout &lt;&lt; endl;&#125; 但是这样显得更复杂了点, 而且控制输出分隔符的条件也要进行对应修改,所以更宁愿牺牲一点空间, 引入标志变量 1234567int flag = 0;for(int i = 0; i &lt; n; i++) &#123; flag = i % 10; if(flag &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; data[i]; if(flag == 9) cout &lt;&lt; endl;&#125; 如果最后一行不需要输出换行, 修改最后一个条件即可 1if(flag == 9 &amp;&amp; i + 1 &lt; n) cout &lt;&lt; endl; 不过这样还是要变复杂了, 水平不够, 暂未想到更好的方法.","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"}]},{"title":"C语言读入一行文本","date":"2020-01-31T15:12:33.000Z","path":"2020/01/C语言读入一行文本.html","text":"常见的坑问题, 方法可能不是特别完整, 但应该够用. C语言getsC-gets.cview raw123456#include &lt;stdio.h&gt;int main() { char s[20]; gets(s); printf(\"%s\", s);} 此方法不会读入换行 scanfC-scanf.cview raw123456#include &lt;stdio.h&gt;int main() { char s[20]; scanf(\"%[^\\n\\r]\", &amp;s); printf(\"%s\", s);} 此方法不会读入换行 %[]表示输入集合, ^表示排除完整的换行应该为\\n\\r, 如果只排除了\\n, 那么在某些Linux评测机上会出现错误 getchar缺陷版本C-getchar.cview raw1234567#include &lt;stdio.h&gt;int main() { char s[20] = {0}; int i = 0; while((s[i++] = getchar()) != '\\n'); printf(\"%s\", s);} 此方法会读入换行, 而且比较难避免不同评测环境下的换行不同问题. 改进版本C-getchar-better.cview raw1234567891011#include &lt;stdio.h&gt;int main() { char s[20] = {0}; int i = 0; while(1) { s[i] = getchar(); if(s[i] == '\\n' || s[i] == '\\r') break; i++; } printf(\"%s\", s);} C++getlineCPP-getline.cppview raw12345678#include &lt;iostream&gt;using namespace std;int main() { string s; getline(cin, s); cout &lt;&lt; s;} 此方法不会读入换行,相比C语言的所有方法都好的地方就是不受到长度限制, 避免内存溢出攻击.但getline函数实际上有三个参数: input - 获取数据来源的流 str - 放置数据的目标 string delim - 分隔字符 因为分割字符delim的默认值为换行符, 因此可以起到只读一行的效果. cin.getlineCPP-cin-getline.cppview raw12345678910#include &lt;iostream&gt;using namespace std;int main() { char s[1024]; cin.getline(s, 1024); cout &lt;&lt; s &lt;&lt; endl; cin.getline(s, 1024, '\\n'); cout &lt;&lt; s &lt;&lt; endl;} 此方法不会读入换行需要注意的是: 该方法(第一个参数)针对的是char*类型变量 第二个参数是读入的字符串大小count 第三个参数(分隔符delim)忽略时, 为\\n 参考链接[1] https://zh.cppreference.com/w/c/io/fscanf[2] https://zh.cppreference.com/w/cpp/io/basic_istream/getline[3] https://www.cnblogs.com/morui/p/11046579.html","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"}]},{"title":"H3C交换机绑定IPv4","date":"2019-09-21T14:54:54.000Z","path":"2019/09/H3C交换机绑定IP.html","text":"这边提到的是IPv4静态绑定，慢慢整理ing. user-bind 使用范围二层以太网端口视图 指令格式user-bind { ip-addressip-address| ip-addressip-addressmac-addressmac-address| mac-addressmac-address} [ vlanvlan-id] 说明ip-address和mac-address至少要指定一项.如果使用了ARP Detection功能，需要指定vlan.mac-address的格式是 xxxx-xxxx-xxxx 而不是xx:xx:xx:xx:xx:xx. 举例[1]1234# 在端口GigabitEthernet1/0/1上配置一条IPv4静态绑定表项（绑定IP＋MAC）。&lt;Sysname&gt; system-view[Sysname] interface gigabitethernet 1/0/1[Sysname-GigabitEthernet1/0/1] user-bind ip-address 192.168.0.1 mac-address 0001-0001-0001 注意事项第7版中已经删除该指令。某些型号的第5版也不支持该指令. ip source binding该指令有两种格式，视使用范围而定。 系统视图(针对全局所有端口都生效)ip source binding ip-addressip-address mac-addressmac-address 二层以太网端口视图ip source binding { ip-addressip-address| ip-addressip-addressmac-addressmac-address| mac-addressmac-address} [ vlanvlan-id] 说明端口优先使用端口上的静态绑定表项对收到的报文进行匹配，若匹配失败，再与全局静态绑定表项进行匹配。[1] 注意事项[1][1] 一个表项不能在同一个端口上重复绑定，但可以在不同端口上绑定。[2] 当IPv4静态绑定表项与IP Source Guard功能配合时，静态绑定表项中的VLAN参数不作为过滤报文的特征项，VLAN参数指定与否，不影响IP Source Guard功能对报文的过滤结果。[3] 在IPv4静态绑定表项与ARP Detection功能配合时，静态绑定表项中必须指定VLAN参数，且该VLAN为使能ARP Detection功能的VLAN，否则ARP报文将无法通过IPv4静态绑定表项的检查。[4] 配置静态表项时，如果系统中已经存在相同内容的动态表项，则新添加的静态表项将会覆盖已有的动态表项。 arp filter binding这个指令可以限制特定源IP和MAC通过，但本质上并不能算绑定IP，只是因为有限制，所以设备也必须使用IP和MAC，并不能用DHCP获取到该IP。 使用范围二层以太网端口视图 / 二层聚合接口视图 指令格式arp filter bindingip-addressmac-address 注意事项[1]每个端口最多支持配置 8 组允许通过的ARP报文的源IP地址和源MAC地址。不能在同一端口下同时配置命令 arp filter source 和 arp filter binding 。 举例[1]12345# 在GigabitEthernet1/0/1下开启ARP过滤保护功能，# 允许源IP地址为1.1.1.1、源MAC地址为2-2-2的ARP报文通过。&lt;Sysname&gt; system-view[Sysname] interface gigabitethernet 1/0/1[Sysname-GigabitEthernet1/0/1] arp filter binding 1.1.1.1 2-2-2 写在最后&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写这篇文章的时候，本来想抛弃user-bind的，因为在实践过程中发现就算提前指定了个IP给设备，设备依旧会获取到一个新IP，但是又不能上网。而最近在操作S5120的时候，发现它明明是第五版命令，但二层端口下也没有user-bind，然后去找其他绑定IP的方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为知识面窄，搞不清楚arp filter binding、arp filter source、ip verify source、ip source binding这几个指令，大佬也不带我，于是去华三官网查文档，才发现只有ip source binding是用来绑定IP的，其他是安全性命令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别是arp filter source，它是用来保护网关免受ARP攻击的，和我想的绑定IP相差甚远；arp filter binding只能算绑定了半个IP，因为它的作用是只允许指定IP和MAC通过，还要在DHCP上面绑定了IP或者设备上设成静态IP才能算真的绑定了；ip verify source也可以看做绑定命令，但是更像一个缓存，只是在同个设备第二次获取IP的时候不用再请求DHCP，并没有真正绑定。这也就解释了为什么当时用?查指令帮助的时候，有些命令跟的参数不是具体的IP或MAC，而是ip-address和mac-address。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是操作E528的时候，发现二层端口下没有ip source binding指令，只能用user-bind，去官网查了下S5120的ip source binding，发现这两个指令的参数是一样的，但坑在于，ip source binding的说明中有提到使用arp detection trust时必须指定一个VLAN，而user-bind的说明没提到，以前绑定IP的时候都没有指定VLAN，所以就出现了开头的那种情况，然而就算整了，依旧会从DHCP服务器上获取IP。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到最后还是没能搞定这个鬼问题，似乎只能在DHCP服务器上做静态绑定，而交换机本身只能做到限制罢了。（期待被打脸的那天）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇文章其实写好很久了, 当初花了两三天测验, 可能是有什么事情, 哪里疏忽了, 就一直没发, 最近想想还是发了出来, 如果有什么错误请见谅, 提出后我会尽量修改. 参考链接： [1]H3C Document","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"IP","slug":"IP","permalink":"https://i.hstb1230.com/notes/tags/IP/"}]},{"title":"易语言取小数位数","date":"2019-09-08T10:52:45.000Z","path":"2019/09/易语言取小数位数.html","text":"写了两遍，第二次写是因为发现还有1e-005这种操作. getDoubleLength.e1234567891011121314151617181920212223242526272829303132333435363738394041.版本 2.子程序 取小数位数, 整数型, , 最高6位.参数 小数数值, 双精度小数型, 可空.参数 小数文本, 文本型, 可空.局部变量 数值, 文本型.局部变量 xLoc, 整数型, , , 小数点或e的文本位置.局部变量 nLeft, 文本型.局部变量 nRight, 文本型.局部变量 len, 双精度小数型.判断开始 (是否为空 (小数数值) ＝ 假) 数值 ＝ 到文本 (小数数值).判断 (是否为空 (小数文本) ＝ 假) 数值 ＝ 小数文本.默认 返回 (0).判断结束xLoc ＝ 寻找文本 (数值, “e”, , 假).如果真 (xLoc ≠ -1) nLeft ＝ 取文本左边 (数值, xLoc － 1) nRight ＝ 取文本右边 (数值, 取文本长度 (数值) － xLoc) len ＝ 取小数位数 (, nLeft) － 到整数 (nRight) .如果真 (len ＜ 0) 返回 (0) .如果真结束 返回 (len).如果真结束xLoc ＝ 寻找文本 (数值, “.”, , 假).如果真 (xLoc ＝ -1) 返回 (0).如果真结束nRight ＝ 取文本右边 (数值, 取文本长度 (数值) － xLoc).判断循环首 (nRight ≠ “” 且 取文本右边 (nRight, 1) ＝ “0”) .如果真 (取文本长度 (nRight) ＝ 1) nRight ＝ “” 跳出循环 () .如果真结束 nRight ＝ 取文本左边 (nRight, 取文本长度 (nRight) － 1).判断循环尾 ()返回 (取文本长度 (nRight)) 附件： 代码图.png getDoubleLength.e","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"E","slug":"E","permalink":"https://i.hstb1230.com/notes/tags/E/"}]},{"title":"记一次易语言的奇怪坑","date":"2019-09-07T16:24:33.000Z","path":"2019/09/记一次易语言的奇怪坑.html","text":"明明啥也没干，可程序就是出了bug。 重要提示:本文是水文，仅做记录吐槽用，并没有分析底层原因。 昨天给别人写插件的时候，发现一个很奇怪的坑， 给一个子程序(这里称为函数A)传了文本型参数(这里称为原变量)，但没有在函数A里对原变量做任何修改，只是读取它的文本值，可在调用完函数A后，原变量莫名奇妙的变成了空文本，或者是乱码，像是被非法修改了内存一样。 因为易语言的设定是「只要你给我传一个非基本类型的数据变量，我就强制你传的是变量地址而不是变量内容」， 于是我长了个心眼，把原变量拷贝了一份(这里称为新变量)再使用， 但其实就是新变量 ＝ 原变量罢了，因为易语言下的＝实际上是申请一个新变量， 所以操作新变量并不会改变原变量。 可就算这么做了，奇怪的事情还是发生了，原变量依旧像前面一样被非法篡改，简直把我搞懵了。 只好进一步的分析，发现函数A里又把原变量传给了另一个函数(这里称为函数B)，函数B里对新变量做了编码再覆盖操作，可是用前面的方法稍加改造后仍然如此，让我差点怀疑易语言的赋值是不是只拷贝了地址。 再用简单粗暴的调试输出分析了有使用原变量的几处代码后，发现使用前后的原变量内容都没有变化，只有在调用完函数A之后才发生变化，哪怕是在函数A快调用结束之前也没有变化。 所以就更懵逼了，这显然是很不科学的， 而且忘记补充了，我在win10下是没有这个问题的，是换到win7和2008下才出现的。 但是我真的已经尽力了，从快接近底层的地方已经去排查一遍也没有办法，只好简单粗暴的使用了新变量 ＝ 到文本(到字节集(原变量))，然后就非常正常了。 但真的很迷惑啊，难道赋值操作并没有拷贝变量吗，用了几年易语言的我表示真的不能理解(吐血…) 本文完。","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"E","slug":"E","permalink":"https://i.hstb1230.com/notes/tags/E/"}]},{"title":"CentOS7添加6in4隧道","date":"2019-08-21T08:37:14.000Z","path":"2019/08/CentOS7添加6in4隧道.html","text":"阿里云ECS对原生IPv6的支持依旧艰难，只好用上了HE的6in4隧道 检查环境首先要检查系统是否开启IPv6编辑\\etc\\sysctl.conf，确保包含如下配置： 123net.ipv6.conf.all.disable_ipv6 &#x3D; 0net.ipv6.conf.default.disable_ipv6 &#x3D; 0net.ipv6.conf.lo.disable_ipv6 &#x3D; 0 如有修改，请重启系统。 脚本信息保存以下命令为文件(如he-tunnel.sh) 123456789LOCAL_IP6=\"2001:470:abcd:ef::2\" LOCAL_IP4=\"192.168.1.1\"REMOTE_IP6=\"2001:470:abcd:ef::1\" REMOTE_IP4=\"1.1.1.1\"sudo ip tunnel del he-sitsudo ip tunnel add he-sit mode sit remote $REMOTE_IP4 local $LOCAL_IP4 ttl 255sudo ip link set dev he-sit upsudo ip -6 addr add $LOCAL_IP6/64 dev he-sitsudo ip -6 route add default via $REMOTE_IP6 dev he-sit 脚本说明 LOCAL_IP6：HE分配的Client IPv6 Address(不要带/64) LOCAL_IP4：用于访问外网的网卡IP，专有网络系列是内网IP，早期的经典网络系列是公网IP REMOTE_IP6：HE分配的Server IPv6 Address(不要带/64) REMOTE_IP4：Server IPv4 Address，即服务器IP 注意事项运行脚本前，请先确保主机能ping通HE的服务器IP，如果能ping通，但运行脚本后仍访问不了IPv6网站，请更换其他地区的隧道服务器。 第一次运行脚本会输出delete tunnel &quot;he-sit&quot; failed: No such device，无需在意。 测试1ping -6 -c 5 -i 3 -I he-sit 2001:470:abcd:ef::1 2001:470:abcd:ef::1为前面的REMOTE_IP6，如果能通就说明配置正确。 设置开机自启编辑/etc/rc.d/rc.local，在末尾追加一行/usr/local/bin/he-tunnel.sh(视脚本的具体路径而定) 部分排错 运行脚本出现bash: ./he-tunnel.sh: Permission denied。 没有执行权限，在脚本目录下执行chmod 755 he-tunnel.sh即可。 运行脚本出现RTNETLINK answers: Permission denied。 根据第一步操作，检查系统是否开启对IPv6的支持。 运行脚本出现RTNETLINK answers: No route to host。 一般和上一个错误一起出现，开启IPv6支持后未遇到，待补充。 无法ping通其他IPv6地址。 检查脚本中的LOCAL_IP4是否设置为用于访问外网的网卡的IP。 运行脚本出现RTNETLINK answers: File exists。 检查是否添加了多个隧道，如果不想删除其他隧道，请将脚本最后一行中的default修改为$REMOTE_IP6/64 刚开始能用电脑ping通服务器地址(这里指自己的服务器)，但是过一段时间就不行了。 检查防火墙或安全组是否放通41协议(不是TCP，也不是UDP，只是个协议号，也称GRE)，同时不要忘记检查服务商的安全组策略。 如果无法操作防火墙，可以加一个定时任务，执行内容为前面的测试脚本。 系统启动后未自动创建隧道 检查文件/etc/rc.d/rc.local是否有执行权限。 参考链接： Tsinghua isatap Example Configurations 阿里云通过He.net添加IPV6","tags":[{"name":"IPv6","slug":"IPv6","permalink":"https://i.hstb1230.com/notes/tags/IPv6/"},{"name":"隧道","slug":"隧道","permalink":"https://i.hstb1230.com/notes/tags/%E9%9A%A7%E9%81%93/"}]},{"title":"Python3保存requests的cookies","date":"2019-08-12T09:07:50.000Z","path":"2019/08/Python3保存requests的cookies.html","text":"用了几天requests后, 发现它的cookie只在本次运行脚本中有效, 这样肯定不行的. 所以要提前保存Cookie, 在下次运行脚本时使用. 目前只看到一个方法, 但是应该不止, 以后会继续补充. 使用pickle保存变量pickle-save.py123456789import pickleimport requestss = requests.Session()s.get('https://aq.qq.com/cn2/index')print(s.cookies)# 将cookies写到文件with open('cookie', 'wb') as f: pickle.dump(s.cookies, f) 恢复变量pickle-load.py12345# 从文件中读取cookieswith open('cookie', 'rb') as f: # 使用update方法或者直接赋值 s.cookies.update(pickle.load(f)) # s.cookies = pickle.load(f) 附录 pickle-save.py pickle-load.py","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"Python3","slug":"Python3","permalink":"https://i.hstb1230.com/notes/tags/Python3/"},{"name":"requests","slug":"requests","permalink":"https://i.hstb1230.com/notes/tags/requests/"},{"name":"cookie","slug":"cookie","permalink":"https://i.hstb1230.com/notes/tags/cookie/"}]},{"title":"在Python3的requests中使用自签名证书","date":"2019-07-24T03:27:31.000Z","path":"2019/07/在Python3的requests中使用自签名证书.html","text":"在requests下使用代理访问https网站时出现了错误 运行环境Python版本为3.5/3.6/3.7，requests库版本为2.21.0代理软件: Fiddler 4，监听地址为：0.0.0.0:8888. 问题描述一般情况下，我们直接访问https网页是这样的： get_https_1.py123456import requests# 声明一个Session对象s = requests.Session()# 使用该对象的get方法请求网站s.get('https://httpbin.org/user-agent') 但有时候为了抓包做分析，看看提交内容是否正确，就会用到代理 get_https_2.py12345678910111213# 声明一个Session对象s = requests.Session()# 声明一个变量存放代理信息proxies = &#123; \"http\": \"http://127.0.0.1:8888/\", \"https\": \"http://127.0.0.1:8888/\"&#125;# 使用代理的两种方法# [1] 在参数中提交代理信息s.get('https://httpbin.org/user-agent', proxies=proxies)# [2] 修改Session对象的属性s.proxies = proxiess.get('https://httpbin.org/user-agent') 然后就会出错，详细信息如下（过长，请稍微对比后自行略过）： 注： D:\\RunEnvironment\\Python36\\是python程序目录 X:/get_https_2.py是代码文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354D:\\RunEnvironment\\Python36\\python.exe X:/get_https_2.pyTraceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\contrib\\pyopenssl.py\", line 456, in wrap_socket cnx.do_handshake() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\SSL.py\", line 1915, in do_handshake self._raise_ssl_error(self._ssl, result) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\SSL.py\", line 1647, in _raise_ssl_error _raise_current_error() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\OpenSSL\\_util.py\", line 54, in exception_from_error_queue raise exception_type(errors)OpenSSL.SSL.Error: [('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')]During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 594, in urlopen self._prepare_proxy(conn) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 805, in _prepare_proxy conn.connect() File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connection.py\", line 344, in connect ssl_context=context) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 347, in ssl_wrap_socket return context.wrap_socket(sock, server_hostname=server_hostname) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\contrib\\pyopenssl.py\", line 462, in wrap_socket raise ssl.SSLError('bad handshake: %r' % e)ssl.SSLError: (\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",)During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\adapters.py\", line 449, in send timeout=timeout File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py\", line 638, in urlopen _stacktrace=sys.exc_info()[2]) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\util\\retry.py\", line 399, in increment raise MaxRetryError(_pool, url, error or ResponseError(cause))urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='httpbin.org', port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",),))During handling of the above exception, another exception occurred:Traceback (most recent call last): File \"X:/get_https_2.py\", line 8, in &lt;module&gt; r = s.get('https://httpbin.org/user-agent') File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 546, in get return self.request('GET', url, **kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 533, in request resp = self.send(prep, **send_kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\sessions.py\", line 646, in send r = adapter.send(request, **kwargs) File \"D:\\RunEnvironment\\Python36\\lib\\site-packages\\requests\\adapters.py\", line 514, in send raise SSLError(e, request=request)requests.exceptions.SSLError: HTTPSConnectionPool(host='httpbin.org', port=443): Max retries exceeded with url: /user-agent (Caused by SSLError(SSLError(\"bad handshake: Error([('SSL routines', 'tls_process_server_certificate', 'certificate verify failed')],)\",),))Process finished with exit code 1 大概说是证书校验错误(certificate verify failed)，于是百度一番 初步解决 在get/post等请求方法中加上参数verify=False1s.get(url, verify=False) 或修改整个session的属性1s.verify = False 彻底解决虽然使用前面的做法后程序不出错了，但是每次通过代理访问https网站时又会出现警告: D:\\RunEnvironment\\Python36\\lib\\site-packages\\urllib3\\connectionpool.py:847: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings 大概意思是「现在创建的是未经验证的https请求，强烈建议添加证书验证」 同时也给了个文档地址，大概是要装certifi库，然后再做一些操作，不过折腾了一会也没搞懂，就放弃了. 后面去Google搜索，看到Stack Overflow上有个问题类似的帖子，阅读了下发现与我的需求差不多： 1requests.get(\"https://www.python.org\", proxies=&#123;\"http\": \"http://127.0.0.1:8888\", \"https\":\"http:127.0.0.1:8888\"&#125;,verify=r\"FiddlerRoot.pem\") I've got to change .cer(DER format) file into .pem(PEM format). And I realized cert parameter was not that I wanted to use. The code above is a solution for me.fx-kirinstackoverflow 后续补充: execute command in a console openssl x509 -inform der -in FiddlerRoot.cer -out FiddlerRoot.pem 大致意思是verify参数可以设置成证书文件的路径，但问题出在需要的是pem格式，而Fiddler导出的证书是cer文件. 所以要使用OpenSSL转换，命令为openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] [FiddlerRoot.cer]为你从Fiddler中导出的cer文件路径(相对或绝对路径) [FiddlerRoot.pem]为导出的pem文件路径. 因为Windows不带OpenSSL程序，为此又特地摸索了几天，头大 执行命令后，将pem文件路径传给verify，或者修改整个Session对象的verify属性即可. 同时，也可以给verify赋值pem文件的所在目录，但要先用OpenSSL附带的c_rehash.pl处理该文件夹. get_https_3.py12345678910111213141516import requests# 声明一个Session对象s = requests.Session()# 修改代理信息s.proxies = &#123; \"http\": \"http://127.0.0.1:8888/\", \"https\": \"http://127.0.0.1:8888/\"&#125;# 设置自定义证书# # 假设证书在代码目录下的cert文件夹里，文件名为FiddlerRoot.pem# # 直接使用相对路径s.verify = r'cert\\FiddlerRoot.pem'# # 如果使用了c_rehash.pl对cert文件夹做了处理，可以修改为如下一行代码s.verify = r'cert's.get('https://httpbin.org/user-agent') 不过这工具(实际上是Perl代码文件)不怎么适应Windows，识别不到openssl路径，所以对它稍作修改，有需要可以在附件下载. 用了这个方法几天，发现还有个奇怪的坑，就是转换的pem文件只能在本次打开的Fiddler中使用，第二次打开Fiddler就会证书错误，但是导入到Windows证书管理后，浏览器是可以一直使用的，所以不知道怎么回事，有需要再摸索吧. 最后补充下这个工具的使用方法吧： 首先需要电脑中要安装perl、openssl并配置环境变量，然后在cmd中执行perl c_rehash.pl pem文件所在目录，如果pem文件所在目录下多出了一个不明代码文件，那么就说明成功了。 二次补充（这次应该是真的最后一次了）： 今天给FTP服务器上TLS的时候，发现openssl生成的证书有效期只有一天，后来查了下，发现在参数列表中加个-days [天数]即可修改有效期.因此也推测转换出来的pem证书也只有一天有效期，而我往往是开一天的Fiddler后才关，所以等我第二次打开Fiddler，也就是第二天的时候，证书自然失效了。所以转换命令应为openssl x509 -inform der -in [FiddlerRoot.cer] -out [FiddlerRoot.pem] -days [3650] 附录本文代码(附件): get_https_1.py get_https_2.py get_https_3.py c_rehash.pl 参考链接: REQUESTS库的文档高级用法 Python Requests and Burp Suite How to capture python https traffic in fiddler? - Stack Overflow How to capture python SSL(HTTPS) connection through fiddler2 - Stack Overflow","tags":[{"name":"Python3","slug":"Python3","permalink":"https://i.hstb1230.com/notes/tags/Python3/"},{"name":"requests","slug":"requests","permalink":"https://i.hstb1230.com/notes/tags/requests/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb1230.com/notes/tags/HTTPS/"},{"name":"proxy","slug":"proxy","permalink":"https://i.hstb1230.com/notes/tags/proxy/"}]},{"title":"JavaScript取网址请求串","date":"2019-02-03T17:23:27.000Z","path":"2019/02/JavaScript取网址请求串.html","text":"准确来说应该是取域名后面的那串文本，但是实在是不知道叫什么。 方法：使用substring截取url中在域名后面的文本。 12345678function getQuery() &#123; var href = window.location.href; // url var host = window.location.host; // 域名 var query = href.substring( href.lastIndexOf(host) + host.length, // 要加长度 href.length ); return query;&#125; 效果： 12当前URL：http:&#x2F;&#x2F;localhost&#x2F;manage&#x2F;?test#123456调用结果：&#x2F;manage&#x2F;?test#123456 使用场景：登录状态失效或不存在时，在跳转到登录页前获取当前功能页地址并传递给接口，登录后成功后跳转至该页面，优化用户体验。","tags":[{"name":"日常丢人","slug":"日常丢人","permalink":"https://i.hstb1230.com/notes/tags/%E6%97%A5%E5%B8%B8%E4%B8%A2%E4%BA%BA/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://i.hstb1230.com/notes/tags/JavaScript/"}]},{"title":"升级HTTPS需要注意的坑","date":"2017-10-12T16:21:26.000Z","path":"2017/10/升级HTTPS需要注意的坑.html","text":"没错，就是我，又来水文章的我。 但是今天应该算是来放干货的。 应该来说，从最开始的有个小绿锁到防运营商的广告污染，HTTPS 已经成了未来站点的发展趋势，那么对应的，网上一定也会出现各种眼花缭乱的教程(包括我的，虽然我之前根本没写过的说)但这些教程总是缺点东西，我写这篇文章的目的就是为了补充一下一些坑。 那啥，怎么HTTP → HTTPS就不说了哈，我只是想说下升级到 HTTPS 后需要注意的地方。 众所周知，HTTPS 网页里面不能引用 HTTP 资源，不然会被浏览器标记为不安全，(也就是没有小绿锁，好好的逼格就这样被吃了)，那么，相信很多教程会建议你们把带有http://的内容替换成https://或者//，再高端一点的，会教你们用 世界上最好的 PHP 写个代理程序，然后配合 JavaScript 食用，这样做大概是因为某些资源站点不支持 HTTPS 。 而我就不一样了，作为一个经常长草的静态博客，我既不太想不能用拍簧片 PHP，又想看到小绿锁，那我总得找个折中的办法： 在&lt;head&gt;标签下加上这样一行&lt;meta&gt;标签，就可以让浏览器强制使用 HTTPS 协议获取网页引用的所有资源： 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt; 千万不要和我说你不知道怎么加(手动再见) 下面是效果对比： 添加前的网络访问情况 添加后的网络访问情况，敢跟我说这是审查元素改出来的效果，请主动把头伸过来，让我给你加个五毛特效 有几点得强调下： 我没测试过各大浏览器的兼容情况，据我临时百度了解，这是 W3C 在 2012 年发布的新标准里的一个内容，但我想，是个现代浏览器应该都支持。 不要以为这个 META 标签是万能的，万一你引用的资源站点只支持 HTTP 协议访问，那么不好意思，该丢的只能丢了，建议有条件的还是用代理方式获取对应资源吧。 来自咸鱼的话： 资源链接最好用//，因为浏览器会自动识别当前协议(HTTP/HTTPS)，不然以后出个新的协议又要改，那就又要接着改。 关于HTTPS网页里不能引用HTTP资源这点可能会有些争议，我印象里前两年的Chrome好像是这样。不要奇怪这个发布时间和更新，文章确实是那个时候开始写的，只不过今天(2018/04/02)才写完，原谅我的懒癌 希望终有一天，所有的站点都能上HTTPS吧","tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://i.hstb1230.com/notes/tags/HTTPS/"}]},{"title":"用PHP取图像颜色","date":"2017-10-05T17:26:38.000Z","path":"2017/10/用PHP取图像颜色.html","text":"对 将图片转为Html网页 以及发布在Github的 img2html 项目代码的一些补充 对于拥有丰富的扩展和类库的PHP来说，提取图像颜色并非难事，使用自带的GD扩展，借助其中的函数即可完成。 首先，我们需要借助 imagecreatefrom 开头的函数导入图像，(怎么获取数据就自己来吧，file_get_contents 之类的) 官方文档列出了以下函数： imagecreatefrombmp imagecreatefromgd2 imagecreatefromgd2part imagecreatefromgd imagecreatefromgif imagecreatefromjpeg imagecreatefrompng imagecreatefromstring imagecreatefromwbmp imagecreatefromwebp imagecreatefromxbm imagecreatefromxpm 这些函数均只有一个参数，但需要注意的是， 除了 imagecreatefromstring 函数外，其余函数的参数需要为文件的本地路径或网络地址，而 imagecreatefromstring 函数的参数只能为文件数据，并且 imagecreatefromstring 函数可以解析 JPEG，PNG，GIF，WBMP 和 GD2 图片文件。 这里用 png图片 做解析，因此先 1$img = imagecreatefrompng('https://img.1sls.cn/Pic/png/6acc6a5b9267214e5f4f4ae12ad4a396'); 然后取图像的宽度与高度： 12$Y = imagesy($i); //取高度$X = imagesx($i); //取宽度 如果我们要计算图像颜色的平均值，那么: 12$rgb = 0; //用于统计颜色总值$n = $X * $Y; //用于记录像素点数量 然后先创建一个遍历行的循环： 12for ($y=0; $y&lt;$Y; $y++) &#123; //循环行&#125; 再创建一个遍历列的循环，但是需要嵌套在行里，即： 1234for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 &#125;&#125; 这时借助 imagecolorat 函数，取出指定像素点的颜色值(十进制)： 12345for ($y=0; $y&lt;$Y; $y++) &#123; //循环行 for ($x=0; $x&lt;$X; $x++) &#123; //循环列 $rgb += imagecolorat($i,$x,$y); //取出点($x,$y)的颜色值后，叠加计算 &#125;&#125; 然后计算图像的平均颜色值： 1$rgb = $rgb / $n; 得到的颜色值是 10进制 的，如果要转换成 16进制，可以借助函数 dechex。 最后，记得释放资源： 1imagedestroy($i);","tags":[{"name":"PHP","slug":"PHP","permalink":"https://i.hstb1230.com/notes/tags/PHP/"},{"name":"图像操作","slug":"图像操作","permalink":"https://i.hstb1230.com/notes/tags/%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/"}]},{"title":"配置Notepad++的c语言运行脚本","date":"2017-10-04T17:41:36.000Z","path":"2017/10/配置Notepad-的c语言运行脚本.html","text":"上个月正式升级为一名学编程的大学生，不出意料，学校教我们C语言。因为暂时不想使用IDE，所以只好自己安装编译器了，受以前初学时候的影响，我用了MinGW。 因为没有IDE，如果我要编译代码以及运行调试，就需要借助cmd，但是每次都要输一遍cd那些代码，即使是复制黏贴，也是很烦人的，更何况我还懒。 后面想到把notepad++自带的运行功能与cmd结合一下，应该就方便很多。 然后上网查方法，看到的教程都是这样给的： 复制以下代码，取名编译C：cmd /k gcc -o &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT 复制以下代码，取名运行C：cmd /c &quot;$(CURRENT_DIRECTORY)\\$(NAME_PART).exe&quot; &amp; PAUSE &amp; EXIT 仔细分析下，就会发现调试需要分两步操作，有点麻烦 所以我改了一下代码，将编译运行一步到位： 1cmd /k gcc -o \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" \"$(FULL_CURRENT_PATH)\" &amp;&amp; \"$(CURRENT_DIRECTORY)/$(NAME_PART).exe\" &amp; PAUSE &amp; EXIT 不过这样做有一个缺点，就是编译出错时，仍然会运行一次程序，如果之前又编译成功过，那么就有可能会误导你。","tags":[{"name":"C语言","slug":"C语言","permalink":"https://i.hstb1230.com/notes/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"环境配置","slug":"环境配置","permalink":"https://i.hstb1230.com/notes/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Notepad++","slug":"Notepad","permalink":"https://i.hstb1230.com/notes/tags/Notepad/"}]}]